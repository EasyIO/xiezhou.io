<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用的linux工具]]></title>
    <url>%2F2021%2F06%2F16%2Flinux-centos-useful%2F</url>
    <content type="text"><![CDATA[Tcpdump12345678# 混杂模式ifconfig ens192 promisc,设置网卡eth0为混杂模式ifconfig ens192 -promisc 取消网卡eth0的混杂模式# tcpdump -抓取主机192.25.0.1和主机192.25.0.2或者192.25.0.3通信sudo -s tcpdump -i ens192 'host 192.25.0.1 and (192.25.0.2 or 192.25.0.3) -w tcpdump-report/0330001.cap#查看文件tcpdump -r xxx.cap WC-l12#grep的or写法\|cat prod-access.log |grep "xxx"|grep "xxx\|xxx\|xxx"|wc -l 连接数12345678# mqtt笔记cd /utcloud/utbroker/logsnetstat -apl|grep 9005#连接数netstat -n|grep ^tcp|awk '&#123;print $NF&#125;'|sort -nr|uniq -c#统计netstat -apn|grep 9005|wc -llsof -i|grep 9005 内存分析perf123456perf topperf --helpperf listperf recordperf report perf report -i perf.data //-i表示文件输入 增加端口数量123456vi /etc/sysctl.conf/sbin/sysctl -pnet.ipv4.ip_local_port_range=10000 60000***service iptables stopcat /proc/sys/net/ipv4/ip_local_port_range 9000 65500 mock程序后台运行1234nohup python3 /home/mock/project/japronto/main.py 1&gt;/dev/null 2&gt;&amp;1 &amp;#输入exit退出终端，关闭shell***python3 /home/mock/project/japronto/main.py***nohup python -u xx.py &gt; log.out 2&gt;&amp;1 &amp; 服务器信息12345678910111213141516#CPU信息：lscpu#内存：cat /proc/meminfo | grep MemTotal#磁盘：fdisk -l | grep Diskdf -hl#内核：uname -auname -r#物理cpu个数cat /proc/cpuinfo|grep "cores"|uniq#查看逻辑cpu个数cat /proc/cpuinfo|grep "processor" |wc -l#cpu核数cat /proc/cpuinfo|grep "physical id"|sort|uniq| wc -l Supervisor123456789101112#更改 Supervisor 启动时的配置文件路径。#1.停止 Supervisor 所有的监控对象supervisorctl stop all#2.停止 kill -9 supervisord 进程#3.修改配置文件vim /etc/supervisord.conf#4.修改 tmp 路径，我常用的路径为 /home/supervisor ，最终结果为/tmp/supervisor.sock =&gt; /home/supervisor/supervisor.sock#5.重新启动 supervisord 。****supervisorctl status****supervisorctl restart xxx]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx限制IP配置]]></title>
    <url>%2F2021%2F06%2F16%2Fnginx-ip%2F</url>
    <content type="text"><![CDATA[多站点统一限IP12345678vim nginx.confallow 127.0.0.1;deny all;# 以上代码解释：# deny all; 限制所有的ip# allow ip; 除了 这个ip意外# 处理allow 以外的ip，全都禁止访问# 注意：多站点统一限ip,需要将以上内容直接写在server&#123;&#125;的外围 站点限IP1234567891011121314vim www.XXX.confserver&#123; server_name www.XXX.com; location ~ / # 不是 ~ /\. &#123; allow 127.0.0.1; deny all; &#125;&#125; # 以上代码解释：# deny all; 限制所有的ip# allow ip; 除了 这个ip意外# www.xxx.com的域名只允许allow的ip访问，其他全都禁止访问# 注意：单站点统一限ip,需要将以上内容直接写在 某一域名配置的server&#123;&#125;内 站点限项目路径访问12345678910vim www.XXX.conflocation ^~ /process-bar/ &#123; deny all;&#125;# 以上代码解释：# ^~ /process-bar/ 以/process-bar/ 开头的项目路径# deny all; 限制所有的ip# www.xxx.com的域名，以/process-bar/ 开头的项目路径，禁止所有ip访问# 注意：单站点统一限制访问项目路径,需要将以上内容直接写在 某一域名配置的server&#123;&#125;内]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的SQL]]></title>
    <url>%2F2021%2F06%2F16%2Fuseful-sql%2F</url>
    <content type="text"><![CDATA[常用的SQL123456789101112131415161718192021--消耗cpu最高的10条语句select * from (select address,hash_value, round(cpu_time/1000000) cpu_time_s, round(cpu_time/decode(executions,0,1,executions)/1000000,2) cpu_time_per, executions, SQL_TEXT from v$sqlarea order by cpu_time_s desc) where rownum &lt;= 10; --查询前10条性能差的sql语句SELECT * FROM (select PARSING_USER_ID,EXECUTIONS,SORTS,COMMAND_TYPE,DISK_READS,sql_text FROM v$sqlarea order BY disk_reads DESC )where ROWNUM&lt;10 ; --查询最占资源的sqlselect b.username username,a.disk_reads reads,a.executions exec, a.disk_reads/decode(a.executions,0,1,a.executions) rds_exec_ratio, a.sql_text statement from v$sqlarea a,dba_users b where a.parsing_user_id=b.user_id and a.disk_reads&gt;100000; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134---查询指定时间内的racle执行的SQL语句SELECT SYSTIMESTAMP FROM dual;select b.SQL_TEXT,b.FIRST_LOAD_TIME,b.SQL_FULLTEXT,b.PARSING_SCHEMA_NAME from v$sqlarea bwhere b.FIRST_LOAD_TIME between '2018-03-14/09:43:24' and '2018-03-14/09:50:00' order by b.FIRST_LOAD_TIME; ---查询oracle正在执行的sqlselect a.username, a.sid,b.SQL_TEXT, b.SQL_FULLTEXT from v$session a, v$sqlarea b where a.sql_address = b.address;---查询被锁的sqlSELECT object_name, machine, s.sid, s.serial# FROM gv$locked_object l, dba_objects o, gv$session s WHERE l.object_id = o.object_id AND l.session_id = s.sid; ---挂号主键冲突处理 select * from user_constraints a,USER_CONS_COLUMNS b where a.CONSTRAINT_TYPE='P' and a. constraint_name=b.constraint_name and a.constraint_name='PK_REFUND_APPLY';--EMR.IX_PRESC_NO ---查找索引对应的表 select index_name,table_name from user_indexes WHERE index_name ='PK_PCA_PATIENT_SERVICE_CARD_IN' ; --PKG_PCA_CARD---1. 就可以在session级别跳过无效索引作查询。alter session set skip_unusable_indexes=true;--2. 分区索引应适用user_ind_partitions。--3. 状态分4种：-- N/A说明这个是分区索引需要查user_ind_partitions或者user_ind_subpartitions来确定每个分区是否可用；-- VAILD说明这个索引可用；--- UNUSABLE说明这个索引不可用；-- USABLE 说明这个索引的分区是可用的。--- 查询当前索引的状态：select distinct status from user_indexes;---查询那个索引无效：select index_name from user_indexes where status &lt;&gt; 'VALID' AND index_name LIKE 'PK_REFUND_APPLY';--- 详细讲解可参考：http://www.sudu.cn/info/html/edu/20071225/20526.html。---批量rebuild下：select 'alter index '||index_name||' rebuild online;' from user_indexes where status &lt;&gt; 'VALID' and index_name not like'%$$';---查询表中是否有重复的记录SELECT ID,COUNT(1) FROM REFUND_APPLY GROUP BY ID HAVING COUNT(1)&gt;1;---去除表中的重复记录，但去除后需要把对应的索引，主外键添加到表中CREATE TABLE test_table AS SELECT DISTINCT * FROM bms.REFUND_APPLY_DETAIL;DROP TABLE bms.REFUND_APPLY_DETAIL;ALTER TABLE test_table RENAME TO REFUND_APPLY_DETAIL;---恢复索引DROP INDEX PK_REFUND_APPLY;alter index PK_REFUND_APPLY rebuild online;alter index PK_REFUND_APPLY rebuild partition PK_REFUND_APPLY (online);---解除索引和表的关联alter TABLE bms.REFUND_APPLY drop constraint PK_REFUND_APPLY---（索引名）---查询索引的分区SELECT * FROM dba_tab_partitions WHERE table_owner = 'BMS' AND TABLE_NAME LIKE '%REFUND_APPLY%'SELECT * FROM dba_ind_partitions WHERE INDEX_NAME ='PK_REFUND_APPLY' ---批量解锁sqlselect Distinct 'alter system kill session '||chr(39)||b.sid||','||b.serial#||chr(39)||';' As cmd,b.username,b.logon_time from v$locked_object a,v$session b where a.session_id=b.sid --解锁SQL，根据查询出被锁表的SID和SERIAL解锁ALTER system kill session 'SID, SERIAL'; ALTER system kill session '3207, 693'; ---查看哪些用户连到了DB上，使用什么Program连接SELECT s.sid, --Session identifier s.serial#,--Session serial number. Used to uniquely identify a session's objects. p.spid, --Operating system process identifier p.pid, --Oracle process identifier s.username,--Oracle DB username s.osuser,--Operating system client user name s.TERMINAL,--Operating system terminal name s.program,--Operating system program name s.STATUS--Status of the session.ACTIVE,INACTIVE,KILLED,CACHED,SNIPED FROM v$session s,v$process p WHERE p.addr = s.paddr AND s.type != 'BACKGROUND';--查看表空间使用率SELECT a.tablespace_name "表空间名", total / 1024 / 1024 "表空间大小单位M", free / 1024 / 1024 "表空间剩余大小单位M", (total - free) / 1024 / 1024 "表空间使用大小单位M", Round((total - free) / total, 4) * 100 "使用率 [[%]]"FROM (SELECT tablespace_name,Sum(bytes) free FROM DBA_FREE_SPACE GROUP BY tablespace_name) a, (SELECT tablespace_name, Sum(bytes) total FROM DBA_DATA_FILES GROUP BY tablespace_name) bWHERE a.tablespace_name = b.tablespace_name;--查看当前用户下的表名及对应的表空间select segment_name table_name,tablespace_name,bytesfrom user_segments where segment_type = 'TABLE' AND segment_name LIKE '%LOG%' ; --- empward.datSELECT bed_id,bed_code,nursing_unit_code,ward_code FROM pts.BED_INFO WHERE status_code!='A'AND nursing_unit_code='213415' ORDER BY bed_code ---oracle断开用户select 'alter system kill session '''||sid||','||serial#||''';' from v$session;---当前的连接数select count(*) from v$session; SELECT COUNT(*) FROM v$process;----并发连接数Select count(*) from v$session where status='ACTIVE';--数据库允许的最大连接数select value from v$parameter where name = 'processes' ;---最大连接 show parameter processes;----查看不同用户的连接数select username,count(username) from v$session where username is not null group by username;--重启数据库:shutdown immediate;startup;]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导航模板]]></title>
    <url>%2F2021%2F06%2F15%2Fbookmark-demo%2F</url>
    <content type="text"><![CDATA[导航模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- import CSS --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;el-menu default-active="1" class="el-menu-demo" mode="horizontal" &gt; &lt;!-- 起始 --&gt; &lt;el-menu-item index="1"&gt;&lt;a href="www.xxx.com" target="_blank" &gt;xxx&lt;/a&gt; &lt;/el-menu-item&gt; &lt;!-- 终止 --&gt; &lt;/el-menu&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-card&gt; &lt;el-tabs&gt; &lt;!-- 起始 --&gt; &lt;el-tab-pane label="xxx"&gt; &lt;el-table :data="tableData1" @row-click="click" @row-dblclick="dblclick" style="width: 100%" &gt; &lt;el-table-column type="index" label="ID" &gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="名称" show-overflow-tooltip &gt;&lt;/el-table-column&gt; &lt;el-table-column prop="url" label="地址" show-overflow-tooltip &gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-tab-pane&gt; &lt;!-- 终止 --&gt; &lt;/el-tabs&gt; &lt;/el-card&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;el-aside width="200px"&gt;&lt;/el-aside&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- import Vue before Element --&gt;&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!--&lt;script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;--&gt;&lt;!-- import JavaScript --&gt;&lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt;&lt;!--&lt;script src="https://cdn.bootcss.com/element-ui/2.7.2/index.js"&gt;&lt;/script&gt;--&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: function () &#123; return &#123; visible: false, activeName: 'second', tableData1: [ &#123; "name":"xxx", "url":"xxx" &#125; ], tableData2: [ &#123; "name": "xxx", "url": "xxx" &#125; ], &#125; &#125;, methods: &#123; dblclick(row, event, column) &#123; window.open(row.url); &#125;, click(row, event, column) &#123; this.$notify.info(&#123; title: "小提示", message: "双击当前行可以直接打开页面", duration: 2000 &#125;); &#125;, &#125;, &#125;) &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>技术π</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jmeter使用教程]]></title>
    <url>%2F2021%2F04%2F24%2Fapache-jmeter-learning%2F</url>
    <content type="text"><![CDATA[常用12345./jmeter -n -t XX.jmx -l report/01-result.jtl -e -o report#日志文件配置修改log4j2.xml文件在jmeter所在bin目录下修改log4j2.xml，修改方式如下：修改，level也可以为info,error等，一般jmter执行日志设置成debug 基础知识12345678910111213RPS ：每秒发送请求数QPS（TPS）：每秒钟request/事务 数量RT : 响应时间并发用户 : vuHPS（Hits Per Second） ：每秒点击次数，单位是次/秒。TPS（Transaction per Second）：系统每秒处理交易数，单位是笔/秒。QPS（Query per Second）：系统每秒处理查询次数，单位是次/秒。 对于互联网业务中，如果某些业务有且仅有一个请求连接，那么TPS=QPS=HPS，一般情况下用TPS来衡量整个业务流程，用QPS来衡量接口查询次数，用HPS来表示对服务器单击请求。测试指标一般分为业务指标、资源指标、应用指标、前端指标。业务指标：如并发用户数、TPS（系统每秒处理事务数）、成功率、响应时间。资源指标：如CPU资源利用率、内存利用率、I/O、内核参数（信号量、打开文件数）等。应用指标：如空闲线程数、数据库连接数、GC/FULL GC次数、函数耗时等。前端指标：如页面加载时间、网络时间（DNS、连接时间、传输时间等）。 Jmeter命令行模式123456789101112131415161718192021222324252627282930313233343536373839jmeter -n -t &lt;testplan filename&gt; -l &lt;listener filename&gt;示例： jmeter -n -t testplan.jmx -l test.jtl1、执行测试脚本jmeter -n -t JMeter分布式测试示例.jmx2、指定结果文件及日志路径jmeter -n -t JMeter分布式测试示例.jmx -l report\01-result.csv -j report\01-log.log3、分布式（远程）执行默认服务器列表jmeter -n -t JMeter分布式测试示例.jmx -r -l report\01-result.csv -j report\01-log.log4、分布式（远程）执行执行服务器列表jmeter -n -t JMeter分布式测试示例.jmx -R 10.9.215.47:1029 -l report\01-result.csv -j report\01-log.log5、导出图形结果jmeter -n -t "Thread Group.jmx" -l 111.jtl -e -o report动态线程$&#123;P(threadNum,)&#125; 获取线程组属性$&#123;P(cycle,)&#125; 获取迭代次数属性$&#123;__P(time,)&#125; 获取时间属性jmeter -JthreadNum=10 -Jtime=10 -n -t "Thread Group.jmx" -l 111.jtl -e -o report具体的含义如下：-h 帮助 -&gt; 打印出有用的信息并退出-n 非 GUI 模式 -&gt; 在非 GUI 模式下运行 JMeter-t 测试文件 -&gt; 要运行的 JMeter 测试脚本文件-l 日志文件 -&gt; 记录结果的文件-r 远程执行 -&gt; 在Jmter.properties文件中指定的所有远程服务器-H 代理主机 -&gt; 设置 JMeter 使用的代理主机-P 代理端口 -&gt; 设置 JMeter 使用的代理主机的端口号-e，--reportatendofloadtests 负载测试后生成报告仪表板-o，--reportoutputfolder &lt;参数&gt; 报告仪表板的输出文件夹-j，--jmeterlogfile &lt;参数&gt;jmeter运行日志文件（jmeter.log）-f，-forceDeleteResultFile 强制删除现有结果文件和Web报告文件夹，如果在开始测试之前-L，--loglevel &lt;参数&gt; = &lt;值&gt;[category =]级别，例如jorphan = INFO，jmeter.util = DEBUG或com.example.foo =警告-R，--remotestart &lt;参数&gt;启动这些远程服务器（覆盖remote_hosts）-X，--remoteexit在测试结束时退出远程服务器（非GUI）-g，--reportonly &lt;参数&gt;仅从测试结果文件生成报告仪表板-e，--reportatendofloadtests 负载测试后生成报告仪表板-o，--reportoutputfolder &lt;参数&gt;报告仪表板的输出文件夹 参数文件1234567891011121314151617181920212223242526272829303132333435关键配置说明jmeter.properties 配置说明主要包含以下几个方面的配置：SSL 配置：重点关注下面几个配置# 指定 HTTPS 协议层 # 指定 HTTPS 协议层 https.default.protocol=TLS # 指定 SSL 版本，实际应用中可能需要修改 https.default.protocol=SSLv3 # 设置启动的协议 https.socket.protocols=SSLv2Hello SSLv3 TLSv1 # 缓存控制，控制 SSL 是否可以在多个迭代中重用 https.use.cached.ssl.context=trueJMeter 测试项目自动备份配置 # 设置是否启用自动备份，默认是 true jmeter.gui.action.save.backup_on_save=true # 设置自动备份目录，默认备份至 JMeter 根目录的 backups下 jmeter.gui.action.save.backup_directory= # 设置自动备份项目数，默认为最近 10 个 jmeter.gui.action.save.keep_backup_max_count=10日志管理配置 # 设置日志格式 log_format_type=default # 设置日志输出级别 log_level.jmeter=INFO # 设置 junit 日志输出级别 log_level.jmeter.junit=DEBUG # 设置日志输出目标文件，默认为 jmeter.log log_file=jmeter.logjmeter.bat 关键配置修改 set HEAP=-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m 分布式12345678910111213141516171819#主控机#jmeter.properties#配置远程主机的 IP，默认为本机。用逗号","可以设置多个远程主机remote_hosts=127.0.0.1#多个远程主机指定示例如下,其中:后为端口remote_hosts=127.0.0.1:1099,127.0.0.1:1200,127.0.0.1:1300#jmeter.batset rmi_host=-Djava.rmi.server.hostname=本机 ip#执行机#Jmeter.propertiesremote_hosts=&#123;slave IP&#125;server.rmi.ssl.disable=true #保证远程连接通畅#开放三个默认端口server_port = 1098server.rmi.port=1098server.rmi.localport = 1098#jmeter-serverRMI_HOST_DEF=-Djava.rmi.server.hostname=&#123;slave IP&#125;]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler教程]]></title>
    <url>%2F2021%2F04%2F22%2Ffiddler-learning%2F</url>
    <content type="text"><![CDATA[接口延时：delay121. AutoResponder 点击‘add rule’2. 设置延时时间 *delay:5000 单个断点12341. bpu在请求开始时中断2. bpafter在响应到达时中断3. bps中断HTTP响应状态为指定字符的全部session响应4. bpv/bpm中断指定请求方式的全部session响应 请求前断点（before request): bpu123451. 刷新请求页面：http://www.baidu.com2. 命令行输入：bpu 接口 例如：bpu /api/xxx3. 再次刷新请求页面，获取断点，可以修改任意请求参数4. 修改完成后点击Break On Response，Run to Completion5. 取消断点，在命令行输入： bpu 回车 响应后断点（after response): bpafter123451. 刷新请求页面：http://www.baidu.com2. 命令行输入：bpafter 接口 例如：bpafter /api/xxx3. 再次刷新请求页面，获取断点，可以修改任意返回数据4. 修改完成后点击Run to Completion5. 取消断点，在命令行输入： bpafter 回车 全局断点1234fiddler菜单栏-&gt;rules-&gt;automatic Breakpoints-&gt;选择断点方式，这种方式下设定的断点会对之后的所有HTTP请求有效。有两个断点位置：1. before request：发送请求之后，但是Fiddler代理中转之前，这时可以修改请求的数据。2. after response：服务器相应之后，但是在Fiddler将响应中转给客户端之前。这时可以修改响应的结果。3. 消除断点：点击Rules-&gt;Automatic Breakpoint-&gt;Disabled]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WRK使用教程]]></title>
    <url>%2F2021%2F04%2F22%2Fwrk-learning%2F</url>
    <content type="text"><![CDATA[格式及用法123456789101112131415#https://github.com/wg/wrk使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt; Options: -c, --connections &lt;N&gt; 跟服务器建立并保持的TCP连接数量 -d, --duration &lt;T&gt; 压测时间 -t, --threads &lt;N&gt; 使用多少个线程进行压测，压测时，是有一个主线程来控制我们设置的n个子线程间调度 -s, --script &lt;S&gt; 指定Lua脚本路径 -H, --header &lt;H&gt; 为每一个HTTP请求添加HTTP头 --latency 在压测结束后，打印延迟统计信息 --timeout &lt;T&gt; 超时时间 -v, --version 打印正在使用的wrk的详细版本信 &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G) &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h) 简单压测及结果分析123456789101112131415161718192021wrk -t8 -c200 -d30s --latency http://www.bing.comRunning 30s test @ http://www.bing.com （压测时间30s） 8 threads and 200 connections （共8个测试线程，200个连接） Thread Stats Avg Stdev Max +/- Stdev （平均值） （标准差）（最大值）（正负一个标准差所占比例） Latency 46.67ms 215.38ms 1.67s 95.59% （延迟） Req/Sec 7.91k 1.15k 10.26k 70.77% （处理中的请求数） Latency Distribution （延迟分布） 50% 2.93ms 75% 3.78ms 90% 4.73ms 99% 1.35s （99分位的延迟：%99的请求在1.35s以内） 1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）Requests/sec: 59658.29 （平均每秒处理完成59658.29个请求）Transfer/sec: 22.79MB （平均每秒读取数据22.79MB）]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ApacheBench使用教程]]></title>
    <url>%2F2021%2F04%2F22%2Fapache-apachebench-learning%2F</url>
    <content type="text"><![CDATA[例子12345678910# 模拟1个客户端请求100次：$ ab -n 100 http://www.example.com/# 模拟100个客户端请求10000次$ ab -n 10000 -c 100 http://www.example.com/# 调用POST方法的接口10次，传输的数据格式为JSON$ ab -n 10 -p json-file http://www.example.com/# 调用OPTIONS方法的接口10次$ ab -n 10 -m OPTIONS http://www.example.com/# 输出每次请求的返回信息$ ab -n 10 -v 2 http://www.example.com/ 基础使用123456789101112131415161718192021222324252627282930313233Usage: ab [options] [http[s]://]hostname[:port]/path用法：ab [选项] 地址选项：Options are: -n requests #执行的请求数，即一共发起多少请求。 -c concurrency #请求并发数。 -t timelimit #测试所进行的最大秒数。其内部隐含值是-n 50000，它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout #指定每个请求的超时时间，默认是30秒。 -b windowsize #指定tcp窗口的大小，单位是字节。 -B address #指定在发起连接时绑定的ip地址是什么。 -p postfile #指定要POST的文件，同时要设置-T参数。 -u putfile #指定要PUT的文件，同时要设置-T参数。 -T content-type #指定使用POST或PUT上传文本时的文本类型，默认是'text/plain'。 -v verbosity #设置详细模式等级。 -w #将结果输出到html的表中。 -i #使用HEAD方式代替GET发起请求。 -y attributes #以表格方式输出时，设置html表格tr属性。 -z attributes #以表格方式输出时，设置html表格th或td属性。 -C attribute #添加cookie,比如'Apache=1234'。（可重复） -H attribute #为请求追加一个额外的头部，比如'Accept-Encoding: gzip'。（可重复） -A attribute #对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即,是否发送了401认证需求代码)，此字符串都会被发送。 -P attribute #对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。 -X proxy:port #指定代理服务器的IP和端口。 -V #打印版本信息。 -k #启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认时，不启用KeepAlive功能。 -d #不显示"percentage served within XX [ms] table"的消息(为以前的版本提供支持)。 -q #如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此-q标记可以抑制这些信息。 -g filename #把所有测试结果写入一个'gnuplot'或者TSV(以Tab分隔的)文件。此文件可以方便地导入到Gnuplot,IDL,Mathematica,Igor甚至Excel中。其中的第一行为标题。 -e filename #产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比'gnuplot'格式更有用。 -r #当收到错误时不要退出。 -h #输出帮助信息 -Z ciphersuite #指定SSL/TLS密码套件 -f protocol #指定SSL/TLS协议(SSL3, TLS1, TLS1.1, TLS1.2 or ALL) 模拟压测某个网站首页12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[root@localhost ~]# ab -n 500 -c 10 http://gitee.com/This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking gitee.com (be patient)Completed 100 requestsCompleted 200 requestsCompleted 300 requestsCompleted 400 requestsCompleted 500 requestsFinished 500 requestsServer Software: nginx # 平台前端服务器类型Server Hostname: gitee.com # 服务器主机名Server Port: 80 # 服务器端口Document Path: / # 访问的路径Document Length: 178 bytes # 返回数据大小Concurrency Level: 10 # 并发数Time taken for tests: 3.898 seconds # 整个测试持续的时间Complete requests: 500 # 完成的请求数量Failed requests: 0 # 表示失败的请求数，这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异常，以及无响应后超时的情况。对于超时时间的设置可以用ab的-t参数。而如果接受到的http响应数据的头信息中含有2xx以外的状态码，则会在测试结果显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数，这些请求并不算是失败的请求Write errors: 0 # 输出错误数量Non-2xx responses: 500 # Total transferred: 217500 bytes # 整个场景中的网络传输量，表示所有请求的响应数据长度总和，包括每个http响应数据的头信息和正文数据的长度。注意这里不包括http请求数据的长度，所以Total transferred代表了从Web服务器流向用户PC的应用层数据总长度。通过使用ab的-v参数即可查看详细的http头信息HTML transferred: 89000 bytes # 整个场景中的HTML内容传输量，表示所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中http响应数据中头信息的长度Requests per second: 128.26 [#/sec] (mean) # 每秒钟平均处理的请求数（相当于 LR 中的 每秒事务数）这便是我们重点关注的吞吐率，它等于：Complete requests / Time taken for testsTime per request: 77.964 [ms] (mean) # 每次并发请求时间（当前并发10）Time per request: 7.796 [ms] (mean, across all concurrent requests) # 平均每个请求处理时间，所有并发的请求加一起Transfer rate: 54.49 [Kbytes/sec] received # 平均每秒网络流量# 花费在连接Connect，处理Processing，等待Waiting的时间的最小min，平均值mean，标准差[+/-sd]，中值median，最大表max的一个表。Connection Times (ms) min mean[+/-sd] median maxConnect: 23 27 1.3 27 30 # 连接Processing: 36 49 7.8 50 155 # 处理Waiting: 35 48 7.8 50 154 # 等待Total: 61 75 8.0 76 180 # 总量# 在一定比例的请求服务时间Percentage of the requests served within a certain time (ms) 50% 76 # 50%的用户响应时间小于76毫秒 66% 79 # 66%的用户响应时间小于79毫秒 75% 80 # 以此类推... 80% 81 90% 83 95% 85 98% 87 99% 89 100% 180 (longest request) 注意事项123451.使用-H Content-Type 不能代替-T Content-Type指定Content-Type 头部2.如果提示ab: invalid URL，可能是URL最右边缺少/，例如http://www.example.com需要改为http://www.example.com/。3.需要注意如果压测的HTTP接口是通过返回结果判断是否成功（只要能响应都会返回200状态码），则需要自行去想办法识别失败的请求4.ab属于一个轻量级的压测工具，结果不会特别准确，可以用作参考。追求准确的话，推荐使用jmeter或者LoadRunner。]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacBook常用操作]]></title>
    <url>%2F2020%2F09%2F26%2Fmacbook-set%2F</url>
    <content type="text"><![CDATA[Brew命令行123456789101112131415brew –help #查看brew的帮助brew install git #安装git软件brew uninstall git #卸载git软件brew search git #搜索git软件brew list #显示已经安装软件列表brew update #更新软件brew upgrade git #更新某具体软件brew [info | home] [FORMULA…] #查看软件信息brew cleanup git #单个软件删除，和upgrade一样brew cleanup #删除所有brew outdated #查看那些已安装的程序需要更新brew home * #用浏览器打开brew info * #显示软件内容信息brew deps * #显示包依赖brew config #查看brew配置 安装123456#安装Brewruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"#更换源git -C "$(brew --repo)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.gitgit -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitgit -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git Quicklook插件1234brew cask install qlstephen #查看没有文件扩展名的纯文本文件brew cask install provisionql #预览iOS的.ipa安装包brew cask install qlmarkdown #预览Markdown文件brew cask install quicklook-json #预览json文件 ITerm2安装123456789101112131415161718192021222324252627282930# 终端输入命令，然后输入密码即可将zsh切换成默认shell$ chsh -s /bin/zsh# 安装oh-my-zshsh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"# 插件git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# 刷新source ~/.zshrc# 配置$ zshconfig'source $ZSH/oh-my-zsh.shalias zshconfig="vim ~/.zshrc"alias vimconfig="vim ~/.vimrc"alias ansibleconfig="vim ~/.ansible/ansible.cfg"alias grep='grep --color=auto'alias cls="clear"'#主题使用powerlevel10k'POWERLEVEL9K_MODE='nerdfont-complete'ZSH_THEME="powerlevel10k/powerlevel10k"'#使用颜色配置$ vi ~/.vimrcsyntax enableset background=darkcolorscheme solarized.vim 快捷键 标签 新建标签：command + t关闭标签：command + w切换标签：command + 数字 / command + 左右方向键切换全屏：command + enter查找：command + f 分屏 垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键 command + [ 或 command + ]查看历史命令：command + ;查看剪贴板历史：command + shift + h 其他 清除当前行：ctrl + u到行首：ctrl + a到行尾：ctrl + e前进后退：ctrl + f/b (相当于左右方向键)上一条命令：ctrl + p搜索命令历史：ctrl + r删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w删除到文本末尾：ctrl + k交换光标处文本：ctrl + t清屏1：command + r清屏2：ctrl + l Python安装123456789101112#安装Pythonbrew search pythonbrew install python@3.8#检测文件夹open /usr/local/Frameworks#没有的话执行 sudo mkdir /usr/local/Frameworks#设置权限sudo chown $(whoami):admin /usr/local/Frameworks#修改默认指向alias python="/usr/bin/python3.7"source ~/.bash_profile#查看版本python -V]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>MacBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows]]></title>
    <url>%2F2020%2F09%2F26%2Fwin10-error%2F</url>
    <content type="text"><![CDATA[Win10远程连接错误12345#Windows10远程报错:由于CredSSP加密Oracle修正1.打开注册表，快捷输⼊ “regedit”;2.找⽂件夹 路径：HKLM(缩写)\Software\Microsoft\Windows\CurrentVersion \Policies\System\CredSSP\Parameters,⼤概到System 后就没有了⾃⼰创建⽂件夹就好;3.然后再最底部⽂件夹⾥⾯ 新建 DWORD（32）位的。⽂件名 “AllowEncryptionOracle”，值：2，保存。 MD512win自带MD5校验win / CertUtil -hashfile 文件路径 [算法] MD5]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome快捷键]]></title>
    <url>%2F2020%2F09%2F26%2Fchrome-hotkey%2F</url>
    <content type="text"><![CDATA[标签页和窗口快捷键123456789101112Ctrl+n #打开新窗口Ctrl+t #打开新的标签页，并跳转到该标签页Ctrl+Shift+t #重新打开最后关闭的标签页，并跳转到该标签页Ctrl+Tab #跳转到下一个打开的标签页Ctrl+Shift+Tab #跳转到上一个打开的标签页Alt+← #历史记录上一页Alt+→ #历史记录下一页Ctrl+w #关闭当前标签页Ctrl+1 到 Ctrl+8跳转到特定标签页，Ctrl+9跳转到最后一个标签页Alt+Home #在当前标签页中打开主页Ctrl+Shift+w #关闭所有打开的标签页和浏览器Ctrl+Shift+q #退出Chrome浏览器 功能快捷键123456Ctrl+Shift+b #显示或隐藏书签栏Ctrl+h #在新标签页中打开”历史记录”页Ctrl+j #在新标签页中打开”下载内容”页Shift+Esc #打开 Chrome 任务管理器Ctrl+g #跳转到与查找栏中搜索字词相匹配的下一条内容Ctrl+Shift+g #跳转到与查找栏中搜索字词相匹配的上一条内容 地址栏快捷键123Ctrl+k 或 Ctrl+e 从页面中的任意位置搜索输入搜索字词并按 Alt+Enter 键打开新的标签页并执行 Google搜索Ctrl+l、Alt+d 或 F6 跳转到地址栏 网页快捷键12345678910Ctrl+u #显示当前网页的 HTML 源代码Ctrl+d #将当前网页保存为书签Ctrl+Shift+d #将所有打开的标签页以书签的形式保存在新文件夹中空格键或 PgDn #向下滚动网页，一次一个屏幕Shift+空格或PgUp #向上滚动网页，一次一个屏幕Ctrl 和+ #放大网页上的所有内容Ctrl 和 - #缩小网页上的所有内容Ctrl+0 #将网页上的所有内容恢复到默认大小Ctrl+Shift+d #将所有打开的标签页以书签的形式保存在新文件夹中Esc #停止加载网页]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr安装手册]]></title>
    <url>%2F2020%2F09%2F26%2Fsolr-set%2F</url>
    <content type="text"><![CDATA[单机版1234567891011121314151617181920212223#1、安装linux、jdk、tomcatmkdir /usr/local/solrmkdir /usr/local/solr/solrhomecp -r apache-tomcat-7.0.47 /usr/local/solr/tomcat#2、把solr的压缩包上传到服务器,并解压tar -zxvf solr-4.10.3.tgz.tgz#3、把/root/solr-4.10.3/dist/solr-4.10.3.war包部署到tomcat下。并改名为solr.warcp /root/solr-4.10.3/dist/solr-4.10.3.war /usr/local/solr/tomcat/webapps/solr.war#4、解压war包。启动tomcat⾃动解压。关闭tomcat。删除solr.wartomcat/bin/stratup.sh#5、log相关jar把复制到lib⽬录，/root/solr-4.10.3/example/lib/extcp /root/solr-4.10.3/example/lib/ext/* /usr/local/solr/tomcat/webapps/WEB-INF/lib/#6、Solrhome是存放solr服务器所有配置⽂件的⽬录。在solr-4.10.3/example/solr下cp -r solr /usr/local/solr/solrhome#7、配置tomcat的web.xml，告诉solr服务器solrhome的位置。'&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/usr/local/solr/solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;'#8、启动tomcat，登⼊地址 http://192.168.7.13x:8080/solr 添加分词器123456789101112131415161718192021222324252627282930#1、上传IK Analyzer 2012FF_hf1⽂件#2、需要把分析器的IKAnalyzer2012FF_u1.jar包添加到solr⼯程中cp IKAnalyzer2012FF_u1.jar /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/#3、需要把IKAnalyzer需要的扩展词典及停⽤词词典、配置⽂件复制到solr⼯程的classpathcp IKAnalyzer.cfg.xml ext_stopword.dic mydict.dic /usr/local/solr /tomcat/webapps/solr/WEB-INF/classes'注意：扩展词典及停⽤词词典的字符集必须是utf-8。不能使⽤windows记事本编辑。'#4、配置fieldType。需要在solrhome/collection1/conf/schema.xml中配置。'技巧：使⽤vi、vim跳转到⽂档开头gg。跳转到⽂档末尾：G''&lt;fieldType name="text_ik" class="solr.TextField"&gt;&lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;&lt;/fieldType&gt;'#业务字段配置'&lt;field name="item_title" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="item_sell_point" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="item_price" type="long" indexed="true" stored="true"/&gt;&lt;field name="item_image" type="string" indexed="false" stored="true" /&gt;&lt;field name="item_category_name" type="string" indexed="true" stored="true" /&gt;&lt;field name="item_desc" type="text_ik" indexed="true" stored="false" /&gt;&lt;field name="item_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/&gt;&lt;copyField source="item_title" dest="item_keywords"/&gt;&lt;copyField source="item_sell_point" dest="item_keywords"/&gt;&lt;copyField source="item_category_name" dest="item_keywords"/&gt;&lt;copyField source="item_desc" dest="item_keywords"/&gt;'#5、重启tomcat SolrCloud集群版Zookeeper集群的搭建12345678910111213141516171819202122232425#需要三个zookeeper节点，四个solr节点#上传、安装zookeepertar -zxf zookeeper-3.4.6.tar.gz#在/usr/local/⽬录下创建⼀个solrcloud⽬录。把zookeeper解压后的⽂件夹复制#到此⽬录下三份。分别命名为zookeeper1、2、3mkdir /usr/local/solrcloudmv zookeeper-3.4.6 /usr/local/solrcloud/zookeeper1#配置zookeeper'1、在每个zookeeper⽂件夹下创建⼀个data⽬录mkdir zookeeper/data2、在data⽂件夹下创建⼀个⽂件名称为myid，⽂件的内容就是此zookeeper的编号1、2、3 echo 1 &gt;&gt; myid3、把zookeeper1下conf⽬录下的zoo_sample.cfg⽂件复制⼀份改名为zoo.cfg4、修改zoo.cfg的配置dataDir=/usr/local/solrcloud/zookeeper1/data #data⽬录路径clientPort=2181 #客户端连接的端⼝#集群中节点信息，包括ip地址及投票、选举的端⼝server.1=192.168.7.130:2881:3881server.2=192.168.7.130:2882:3882server.3=192.168.7.130:2883:38835、启动zookpeeker，进⼊zookeeper1/bin⽬录下启动：./zkServer.sh start关闭：./zkServer.sh stop查看状态：./zkServer.sh status' Solr实例的搭建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481、把solrhome中的配置⽂件上传到zookeeper集群。使⽤zookeeper的客户端上传'客户端命令位置：cd /root/solr-4.10.3/example/scripts/cloud-scripts'#上传配置⽂件'./zkcli.sh -zkhost 192.168.7.130:2181,192.168.7.130:2182,192.168.7.130:2183 -cmd upconfig -confdir /usr/local/solrcloud/solrhome1/collection1/conf -confname myconf'#查看是否上传成功'[root@bogon bin]# ./zkCli.shConnecting to localhost:2181[zk: localhost:2181(CONNECTED) 0] ls /[configs, zookeeper][zk: localhost:2181(CONNECTED) 1] ls /configs[myconf][zk: localhost:2181(CONNECTED) 2] ls /configs/myconf''创建四个solr和四个tomcat，tomcat中每个web.xml,需要修改solrhome的位置'2、修改solrhome下的solr.xml⽂件，指定当前实例运⾏的ip地址及端⼝号'&lt;solrcloud&gt; &lt;str name="host"&gt;$&#123;host:192.168.7.130&#125;&lt;/str&gt; &lt;int name="hostPort"&gt;$&#123;jetty.port:8080&#125;&lt;/int&gt; &lt;str name="hostContext"&gt;$&#123;hostContext:solr&#125;&lt;/str&gt; &lt;int name="zkClientTimeout"&gt;$&#123;zkClientTimeout:30000&#125;&lt;/int&gt; &lt;bool name="genericCoreNodeNames"&gt;$&#123;genericCoreNodeNames:true&#125;&lt;/bool&gt;&lt;/solrcloud&gt;'3、修改每⼀台solr的tomcat 的 bin⽬录下catalina.sh⽂件中加⼊DzkHost指定zookeeper服务器地址：'JAVA_OPTS="-DzkHost=192.168.7.130:2181,192.168.7.130:2182,192.168.7.130:2183"'4、重新启动tomcat，此时⼀个主节点多个备份节点，集群只有⼀⽚。5、创建⼀个两⽚的collection，每⽚是⼀主⼀备。'http://192.168.7.130:8080/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2'6、删除collection1'http://192.168.7.130:8080/solr/admin/collections?action=DELETE&amp;name=collection1'#安装完成]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装手册]]></title>
    <url>%2F2020%2F09%2F26%2Fredis-set%2F</url>
    <content type="text"><![CDATA[单机版123456789101112#安装redisyum intall gcc-c++tar -zxvf redis-3.0.0.tar.gzcd redis-3.0.0Makemake install PREFIX=/usr/local/redis#启动redis#修改redis.conf⽂件'daemmonize yes'./redis-server redis.conf 集群版安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#安装rubyyum install -y rubyyum install -y rubygems#redis集群管理⼯具redis-trib.rb#在/redis-3.0.0/src⽬录下cp redis-trib.rb /usr/local/redis-cluster/redis-trib.rb#安装redis-3.0.0.gemgem install redis-3.0.0.gem#集群搭建#创建6个redis实例，端⼝7001-7006#修改redis.conf'port 7001''cluster-enabled yes'#创建⽂件夹mkdir /usr/local/redis-clustercp -r /usr/local/redis/bin /usr/local/redis-cluster/redis01#修改redis.conf 端⼝cp -r redis01 redis02#启动实例，编写⼀个便捷脚本startall.sh'cd redis01./redis-server redis.confcd ..cd redis02./redis-server redis.confcd ..cd redis03./redis-server redis.confcd ..cd redis04./redis-server redis.confcd ..cd redis05./redis-server redis.confcd ..cd redis06./redis-server redis.confcd ..'chmod +x startall.sh./startall.sh#创建集群#redis集群⾄少需要3个主节点，每个主节点有⼀个从节点总共6个节点#replicas指定为1表示每个主节点有⼀个从节点'./redis-trib.rb create --replicas 1 192.168.7.131:7001 192.168.7.131:7002 192.168.7.131:7003 192.168.7.131:7004 192.168.7.131:7005 192.168.7.131:7006'#测试集群./redis-cli -h 192.168.7.131 -p 7002 -c'(-c连接集群)'#查询集群节点信息cluster nodes#查询集群状态信息cluster info#关闭reidsredis01/redis-cli -p 7001 shutdown 添加主节点1234567891011121314#添加7007节点./redis-trib.rb add-node 192.168.7.131:7007 192.168.7.131:7001'如添加失败，删除dump.rdb，nodes.conf再重启'#确认已添加#hash槽重新分配'添加完主节点需要对主节点进⾏hash槽分配这样该主节才可以存储数据。redis集群有16384个槽，集群中的每个结点分配⾃已槽，通过查看集群结点可以看到槽占⽤情况。'#第⼀步：连接上集群./redis-trib.rb reshard 192.168.101.3:7001#第⼆步：输⼊要分配的槽数量#第三步：输⼊接收槽的结点id'通过cluster nodes查看7007结点'#第四步：输⼊源结点id输⼊all.done为取消分配 添加从节点12345678#添加7008从结点，将7008作为7007的从结点'./redis-trib.rb add-node --slave --master-id 主节点id 添加节点的ip和端⼝集群中已存在节点ip和端⼝''./redis-trib.rb add-node --slave --master-id 4a9ce829134ead6fca2df6206bfa1b05246b3923 192.168.7.131:7008 192.168.7.131:7001']]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ安装手册]]></title>
    <url>%2F2020%2F09%2F26%2Frabbitmq-set%2F</url>
    <content type="text"><![CDATA[Erlang安装1234567891011121314151617#安装依赖环境yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel#解压tar -xvzf otp_src_20.0.tar.gz#安装./configure --prefix=/root/erlang --with-ssl -enable-threads -enable-smmp-support -enable-kernel-poll --enable-hipe --without -javac#编译及安装make &amp;&amp; make install#配置环境变量vi /etc/profilePATH=$PATH:/root/erlang/bin#⽣效source /etc/profile#验证安装成功erl RabbitMQ安装123456789#解压xz -d rabbitmq-server-generic-unix-3.7.6.tar.xztar -xvf rabbitmq-server-generic-unix-3.7.6.tar#进⼊sbin⽂件cd rabbitmq_server-3.7.6/sbin#启⽤web管理界⾯./rabbitmq-plugins enable rabbitmq_management#添加配置⽂件rabbitmq.conf 服务管理123456789101112#启动rabbitmq-server -detached / start#查看状态rabbitmqctl status#关闭服务rabbitmqctl stop#列出⻆⾊rabbitmqctl list_users#开启某个插件：rabbitmq-pluginsenable xxx#关闭某个插件：rabbitmq-pluginsdisable xxx virtual_host管理1234新建rabbitmqctl add_vhost xxx删除rabbitmqctl delete_vshot xxx 用户管理123456789新建rabbitmqctl add_user admin admin删除rabbitmqctl delete_user admin改密rabbitmqctl change_password amdin 123456设置⽤户⻆⾊rabbitmqctl set_user_tags admin administrator'Tag可以为 administrator,monitoring,policymaker,management' 权限管理1234567891011121314151617#添加权限rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"#修改⽤户⻆⾊rabbitmqctl set_user_tags username administrator'权限设置说明：rabbitmqctl set_permissions [-pvhostpath] &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;Vhostpath：Vhost路径。user：⽤户名。Conf：⼀个正则表达式match哪些配置资源能够被该⽤户访问。Write：⼀个正则表达式match哪些配置资源能够被该⽤户读。Read：⼀个正则表达式match哪些配置资源能够被该⽤户访问。'#查看(指定hostpath)所有⽤户的权限信息rabbitmqctl list_permissions -p /#查看指定⽤户的权限信息rabbitmqctl list_user_permissions User#清除⽤户的权限信息rabbitmqctl clear_permissions admin 获取服务器状态信息1234567891011121314151617181920212223rabbitmqctl status #获取服务器状态：rabbitmqctl stop_app #关闭应⽤rabbitmqctl start_app #启动应⽤rabbitmqctl reset #清除所有队列rabbitmqctl list_queues #查看所有队列信息#获取队列信息#Queueinfoitem可以为：name，durable，auto_delete，arguments，messages_ready，#messages_unacknowledged，messages，consumers，memory。rabbitmqctl list_queues[-p vhostpath] [queueinfoitem ...] #获取Exchange信息#Exchangeinfoitem有：name，type，durable，auto_delete，internal，arguments。rabbitmqctllist_exchanges[-p vhostpath] [exchange infoitem ...]#获取Binding信息：#Bindinginfoitem有：source_name，source_kind，destination_name，destination_kind，#routing_key，arguments。rabbitmqctllist_bindings[-p vhostpath] [bindinginfoitem ...]#获取Connection信息#Connectioninfoitem有：recv_oct，recv_cnt，send_oct，send_cnt，send_pend等。rabbitmqctllist_connections [connectioninfoitem...]#获取Channel信息#Channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，#acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked。rabbitmqctl list_channels[channelinfoitem ...]]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装手册]]></title>
    <url>%2F2020%2F09%2F26%2Fnginx-set%2F</url>
    <content type="text"><![CDATA[安装12345678910111213141516171819202122232425262728293031323334#安装环境yum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel#编译安装tar -zxvf nginx-1.8.0.tar.gzcd nginx-1.8.0'./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi''注意：上边将临时⽂件⽬录指定为/var/temp/nginx，需要在/var下创建temp及nginx⽬录'#编译安装make &amp;&amp; make install#启动nginxcd /usr/local/nginx/sbin./nginx#指定配置⽂件加载./nginx -c /usr/local/nginx/conf/nginx.conf#停⽌nginx#快速停⽌ 此⽅式相当于先查出nginx进程id再使⽤kill命令强制杀掉进程./nginx -s stop#完整停⽌ 此⽅式停⽌步骤是待nginx进程处理任务完毕进⾏停⽌./nginx -s quit#重新加载配置⽂件./nginx -s reload 问题12345'CentOS启动nginx出现nginx: [emerg] open() "/var/run/nginx/nginx.pid" failed (2: No such file or director）'#解决⽅法，在run下创建nginx⽂件夹，并新建nginx.pid;mkdir /var/run/nginxtouch /var/run/nginx/nginx.pid Nginx实现虚拟机IP区分虚拟主机(单机多IP)123456789101112131415161718192021222324252627282930#将/etc/sysconfig/network-scripts/ifcfg-ens33⽂件复制⼀份，#命名为ifcfg-ens33:1修改其中内容：'DEVICE=ens33:1IPADDR=192.168.7.xxx'#'重启系统'#修改nginx.conf'server &#123; listen 80; server_name 192.168.7.137; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-137; index index.html index.htm; &#125;&#125;server &#123; listen 80; server_name 192.168.7.138; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-138; index index.html index.htm; &#125;&#125;' 基于端口(同IP不同端口区分项目)12345678910111213141516171819202122'server &#123; listen 80; server_name 192.168.7.137; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-137; index index.html index.htm; &#125;&#125;server &#123; listen 81; server_name 192.168.7.137; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-81; index index.html index.htm; &#125;&#125;' 基于域名(通过域名区分项目)12345678910111213141516171819202122232425#修改window的hosts⽂件：（C:\Windows\System32\drivers\etc）#添加host#192.168.7.137 www.123.com#192.168.7.137 sso.123.com'server &#123; listen 80; server_name www.123.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-www; index index.html index.htm; &#125;&#125;server &#123; listen 80; server_name sso.123.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-hehe; index index.html index.htm; &#125;&#125;' 反向代理12345678910111213141516171819202122232425262728293031323334#可通过不同域名访问不同服务器，访问被nginx拦截，#启两台tomcat，修改server.xml中端⼝#则访问到 192.168.7.137:8080 192.168.7.137:8081#host⽂件添加'192.168.7.137 8080.bt0a.com192.168.7.137 8081.bt0a.com'#nginx.conf添加'upstream tomcat1&#123; server 192.168.7.137:8080;&#125;upstream tomcat2&#123; server 192.168.7.137:8081;&#125;server&#123; listen 80; server_name 8080.bt0a.com; location / &#123; proxy_pass http://tomcat1; index index.htm index.html;&#125;&#125;server&#123; listen 80; server_name 8081.bt0a.com; location / &#123; proxy_pass http://tomcat2; index index.htm index.html; &#125;&#125;' 负载均衡1234567891011121314#修改nginx.conf'upstream tomcat1&#123; server 192.168.7.137:8080 weight=2; server 192.168.7.137:8081 weight=1; #loadbalance&#125;'#负载均衡，设备状态配置#'down' 表示单前的server暂时不参与负载#'weight' 默认为1.weight越⼤，负载的权重就越⼤。#'max_fails' 允许请求失败的次数默认为1.当超过最⼤次数时，返回proxy_next_up#stream 模块定义的错误#'fail_timeout:max_fails' 次失败后，暂停的时间。#'backup' 其它所有的⾮backup机器down或者忙的时候，请求backup机器。所以这台机器压⼒会最轻]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装及配置]]></title>
    <url>%2F2020%2F09%2F26%2Fdb-mysql-set%2F</url>
    <content type="text"><![CDATA[MySQL安装123456789101112131415161718192021222324#1、从官⽹源下载https://dev.mysql.com/downloads/repo/yum/wget https://dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm#2、更新/安装 刚才下载下来的包rpm -Uvh mysql80-community-release-el7-2.noarch.rpm-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;：升级指定的套件档；-v：显示指令执⾏过程；-h或--hash：套件安装时列出标记；-Uvh：升级软件包--Update；#3、列出包⾥⾯所有可⽤的版本yum repolist all | grep mysql#4、禁⽤8.0版本，启⽤5.7版本yum-config-manager --disable mysql80-communityyum-config-manager --enable mysql57-community#5、再检查⼀次现在可⽤的版本yum repolist enabled | grep mysql#6、安装yum install mysql-community-server#7、确认版本mysql --version#设置开机启动systemctl enable mysqldsystemctl daemon-reload MySQL初始化12345678910111213141516#1、启动/关闭服务/查看状态systemctl start/stop/status mysqld.service#2、获取密码grep 'temporary password' /var/log/mysqld.log#3、登录mysql -uroot -p#4、修改密码ALTER USER 'root'@'localhost' IDENTIFIED BY 'Xx@123456';#5、远程连接use mysql#在mysql数据库中查看user表中相关的信息select host, user, authentication_string, plugin from user;#更改（localhost 表示只能进⾏本地访问，不能进⾏远程连接）update user set host = "%" where user = "root";#刷新FLUSH PRIVILEGES; 权限设置123456789101112131415161718192021222324252627282930313233GRANT命令说明：#表示所有权限，你也可以使⽤select、update等权限提到的权限ALL PRIVILEGES #⽤来指定权限针对哪些库和表ON #中前⾯的*号⽤来指定数据库名，后⾯的*号⽤来指定表名*.* #表示将权限赋予某个⽤户。TO #表示xu⽤户，@后⾯接限制的主机，可以是IP、IP段、域名以及%，%表示任何地⽅xu@'localhost'#指定⽤户的登录密码IDENTIFIED BY#这个选项表示该⽤户可以将⾃⼰拥有的权限授权给别⼈WITH GRANT OPTION#创建⼀个只允许从本地登录的超级⽤户xu，并允许将权限赋予别的⽤户，密码为Xx@123456GRANT ALL PRIVILEGES ON *.* TO xx@'localhost' IDENTIFIED BY 'Xx@123456' WITH GRANT OPTION#创建⼀个⼀般的程序⽤户，这个⽤户可能只需要SELECT, INSERT, UPDATE, DELETE, #CREATE TEMPORARY TABLES等权限如果有存储过程还需要加上EXECUTE权限，#⼀般是指定内⽹⽹段192.168.100⽹段GRANT USAGE,SELECT, INSERT, UPDATE, DELETE, SHOW VIEW ,CREATE TEMPORARY TABLES, EXECUTE ON `test`.* TO xx@'192.168.100.%'IDENTIFIED BY 'xx@123456';#创建⼀个普通⽤户(仅有查询权限)GRANT USAGE,SELECT ON `test`.* TO xx@'192.168.100.%' IDENTIFIED BY 'xx@123456';#刷新权限FLUSH PRIVILEGES#查看权限SHOW GRANTS FOR 'xx'@'%';#回收权限REVOKE DELETE ON test.* FROM 'xx'@'192.168.100.%';#删除⽤户DROP USER 'xx'@'192.168.100.%'; 基础配置12345678910111213141516171819vim /etc/my.cnf#数据库⼤⼩写lower_case_table_names=1#字符编码character-set-server=utf8#开通⽇志general_log=1#⽇志地址general_log_file=/usr/local/**/general.log#开启慢查询slow_query_log=1#慢查询地址slow_query_log_file=/**/**/slowquery.log#慢查询阀值long_query_time=5#输出⽅式 FILE表示⽂件，TABLE表示数据库log_output=' FILE,TABLE'#添加log⽂件权限chomd 777 log sql_mode=only_full_group_by问题12$ set session sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';]]></content>
      <categories>
        <category>DBπ</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装FTP]]></title>
    <url>%2F2020%2F09%2F26%2Flinux-centos-ftp%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829#安装组件yum -y install vsftpd#添加⽤户useradd ftpuser#添加密码pssswd ftpuser#添加21端⼝vim /etc/sysconfig/iptables#重启iptalessystemtcl restart iptables#修改selinux#查看状态getsebool -a|grep ftp#执⾏setsebool -P allow_ftpd_full_access onsetsebool -P ftp_home_dir on#关闭匿名访问vi /etc/vsftpd/vsftpd.confanonymous_enable=no#重启服务systemtcl restart vsftpd#开启被动模式#vsftpd.conf末尾添加pasv_min_port=30000pasv_max_port=30999#iptables添加 30000:30999#重启#设置开机启动chkconfig vsftpd on]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7最小化安装]]></title>
    <url>%2F2020%2F09%2F26%2Fcentos7-mini%2F</url>
    <content type="text"><![CDATA[网络配置123456789101112131415161718192021#最⼩化安装CentOS7，⾸先需要配置⽹络vi /etc/sysconfig/network-scripts/ifcfg-eno33#修改ONBOOT=yes#静态ipBOOTPROTO=staticIPADDR=192.168.3.130 #本机地址NETMASK=255.255.255.0 #⼦⽹掩码GATEWAY=192.168.3.1 #默认⽹关DNS1=8.8.8.8DNS2=114.114.114.114#重启⽹卡systemctl network restart#查看⽹卡信息ip addr#查看哪些组件包含了ifconfig命令yum 'provides' ifconfig#或yum whatprovides ifconfig#安装yum install -y net-tools SSH安装123456789101112#安装 yum install -y openssh-server#配置/etc/ssh/sshd_configvi etc/ssh/sshd_config# 关于监听端口、监听地址前的 # 号去除port 22ListenAddress 0.0.0.0ListenAddress ::# 然后开启允许远程登录PermitRootLogin yes# 开启使用用户名密码来作为连接验证PasswordAuthentication yes CentOS 时区设置12345678#centos6#查看当前时区设置ls -l /etc/localtime#修改时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime#centos7timedatectl set-timezone Asia/Shanghaitimedatectl status 关闭firewall启用IPtable123456789101112131415161718192021222324252627282930#停⽌firewallsystemctl stop firewall.service#关闭firewall⾃动启动systemctl disable firewall.service#安装iptable防⽕墙yum install -y iptables-services#查看80端⼝占⽤lsof -i tcp:80#列出所有端⼝netstat -ntlp#查看配置iptables -L -n#添加端⼝vi /etc/sysconfig/iptables#添加-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT#或者iptables -A INPUT -p tcp –-dport 80 -j ACCEPT#保存iptables save#重启iptablessystemctl restart iptables.service#添加iptables开机⾃启动systemctl enable iptables.service#查看状态systemctl status iptables#永久关闭防⽕墙chkconfig iptables off#永久关闭后启⽤chkconfig iptables on 关闭SELINUX12345678910vi /etc/selinux/config#注释掉下⾯两⾏SELINUX=enforcingSELINUXTYPE=targeted#增加⼀⾏SELINUX=disabled#保存，关闭#命令设置临时关闭setenfore 0#使设置启⽤，在这⾥最好重启⼀下系统，也可以稍后重启 更换源12345678cd /etc/yum.repo.d#备份mv CentOS-Base.repo CentOS-Base.repo.bak#下载阿⾥源⽂件wget /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#重建源数据缓存yum makecache 第三方源1234567891011#安装 yum-plugin-prioritiesyum install -y yum-plugin-priorities#设置，默认开启vim /etc/yum/pluginconf.d/priorities.confenabled=1 开启enabled=0 关闭#设置默认源的优先级：#⼀般默认的源配置⾥⾯ [base], [updates], [extras]，[centosplus] 的 priority=1， [contrib] 的 priority=2，其他第三的软件源为：priority=N （推荐 N &gt; 10，N 可以为1到99的正整数，数值越⼩越优先）#sudo vim /etc/yum.repos.d/CentOS-Base.repovim安装 vim安装1yum install -y vim-enhanced clean boot12345678# 1.使⽤如下命令查询⽬前安装在系统⾥的全部内核（kernel）$ rpm -q kernel# 2.查询当前使⽤的内核（kernel）版本$ uname -a# 3.删除除当前内核以外所有的内核$ rpm -e '内核版本号'$ rpm -e kernel-2.6.32-358.el6.i686# 4.使⽤命令df -h 查看/boot分区的使⽤情况。 Git升级1234567891011121314151617# 安装编译git时需要的包$ yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum -y install gcc perl-ExtUtils-MakeMaker# 删除已有的git$ yum remove git# 下载git源码$ cd /usr/src$ wget https://www.kernel.org/pub/software/scm/git/git-2.19.2.tar.gz$ tar -xzf git-2.19.2.tar.gz# 编译安装$ cd git-2.19.2$ make prefix=/usr/local/git all$ make prefix=/usr/local/git install$ echo "export PATH=$PATH:/usr/local/git/bin" &gt;&gt; /etc/bashrc$ source /etc/bashrc# 检查⼀下版本号$ git --version npm源更换123456$ alias cnpm="npm --registry=https://registry.npm.taobao.org \--cache=$HOME/.npm/.cache/cnpm \--disturl=https://npm.taobao.org/dist \--userconfig=$HOME/.cnpmrc"# npm升级$ npm update npm Tomcat时区更改1234#在catalina.sh 第⼀⾏家⼀下⼀下脚本JAVA_OPTS='-Xms1024m -Xmx1024m -XX:PermSize=256M -XX:MaxNewSize=512m -XX:MaxPermSize=512m'JAVA_OPTS="$JAVA_OPTS -Dfile.encoding=UTF8 -Duser.timezone=GMT+08" Tomcat端口更改1234#在server.xml更改&lt;Connector port="8088" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; JDK安装1234567891011121314mkdir /usr/javatar -zxvf jdk-8u152-linux-x64.tar.gz#编辑profile⽂件vim /etc/profile向⽂件⾥⾯追加以下内容：#set java environmentJAVA_HOME=/usr/java/jdk1.7.0_79JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH#使配置⽂件⽣效：source /etc/profilejava -version 后台运行nohup123456ps -ef|grep socsi-pay-app-payfor.jarps -ef|grep socsi-pay-app-order-polling.jarps -ef|grep socsi-pay-app-notify.jarnohup java -jar socsi-pay-app-payfor.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;nohup java -jar socsi-pay-app-notify.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;nohup java -jar socsi-pay-app-order-polling.jar 1&gt;/dev/null 2&gt;&amp;1&amp; ngrok1http://127.0.0.1:4040/http/in]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量级运维]]></title>
    <url>%2F2020%2F09%2F26%2Ffast-yunwei%2F</url>
    <content type="text"><![CDATA[CentOS时区设置1234#查看当前时区设置ls -l /etc/localtime#修改时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Tomcat时区更改1234#在catalina.sh 第⼀⾏家⼀下⼀下脚本JAVA_OPTS='-Xms1024m -Xmx1024m -XX:PermSize=256M -XX:MaxNewSize=512m -XX:MaxPermSize=512m'JAVA_OPTS="$JAVA_OPTS -Dfile.encoding=UTF8 -Duser.timezone=GMT+08" Tomcat端口更改1234#在server.xml更改&lt;Connector port="8088" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; JDK安装123456789101112131415mkdir /usr/javatar -zxvf jdk-8u152-linux-x64.tar.gz#编辑profile⽂件vim /etc/profile向⽂件⾥⾯追加以下内容：#set java environmentJAVA_HOME=/usr/java/jdk1.7.0_79JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH#使配置⽂件⽣效：source /etc/profilejava -version 防火墙firewall(弃用)12345678910111213141516171819202122232425262728#1、查看firewall服务状态systemctl status firewalld#2、查看firewall的状态firewall-cmd --state#3、开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop#4、查看防⽕墙规则firewall-cmd --list-all#5、查询、开放、关闭端⼝# 查询端⼝是否开放firewall-cmd --query-port=8080/tcp# 开放80端⼝firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --permanent --add-port=8088/tcpfirewall-cmd --permanent --add-port=3306/tcp# 移除端⼝firewall-cmd --permanent --remove-port=8080/tcp#重启防⽕墙(修改配置后要重启防⽕墙)firewall-cmd --reload# 参数解释#1、firwall-cmd：是Linux提供的操作firewall的⼀个⼯具；#2、--permanent：表示设置为持久；#3、--add-port：标识添加的端⼝； ActiveMQ安装123456789101112tar -zxvf apache-activemq-5.14.0-bin.tar.gz./activemq start#(使⽤IPtables防⽕墙)添加防⽕墙的端⼝8161和61616firewall-cmd --add-port=8161/tcpfirewall-cmd --add-port=6161/tcp查看添加的端⼝firewall-cmd --list-all命令：重启防⽕墙systemctl restart firewalld查看防⽕墙状态firewall-cmd --state#重启防⽕墙(修改配置后要重启防⽕墙)firewall-cmd --reload 后台运行nohup123456ps -ef|grep xxx-pay-app-payfor.jarps -ef|grep xxx-pay-app-order-polling.jarps -ef|grep xxx-pay-app-notify.jarnohup java -jar xxx-pay-app-payfor.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;nohup java -jar xxx-pay-app-notify.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;nohup java -jar xxx-pay-app-order-polling.jar 1&gt;/dev/null 2&gt;&amp;1&amp; ngrok1http://127.0.0.1:4040/http/in]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j.properties 详解与配置步骤]]></title>
    <url>%2F2020%2F09%2F26%2Flog4j-set%2F</url>
    <content type="text"><![CDATA[模板12345678910111213141516171819202122#配置根⽬录log4j.rootLogger = DEBUG, stdout, R#控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppender#可以灵活地指定布局模式log4j.appender.stdout.layout=org.apache.log4j.PatternLayout#输出格式log4j.appender.stdout.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n#写⼊到⽂件（⽂件⼤⼩到达指定尺⼨的时候产⽣⼀个新的⽂件）log4j.appender.R=org.apache.log4j.RollingFileAppender#设置⽇志名，默认存储在tomcat/bin⽬录下log4j.appender.R.File=taotao.log#⽂件⼤⼩（KB, MB 或者是 GB）log4j.appender.R.MaxFileSize=100KB#设置备份log4j.appender.R.MaxBackupIndex=1#可以灵活地指定布局模式log4j.appender.R.layout=org.apache.log4j.PatternLayout#输出格式log4j.appender.R.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n 参数详解 1.输出级别的种类 ERROR、WARN、INFO、DEBUGERROR 为严重错误 主要是程序的错误WARN 为一般警告，比如session丢失INFO 为一般要显示的信息，比如登录登出DEBUG 为程序的调试信息 2.配置日志信息输出目的地 log4j.appender.appenderName = fully.qualified.name.of.appender.classorg.apache.log4j.ConsoleAppender（控制台）org.apache.log4j.FileAppender（文件）org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） 3.配置日志信息的格式 log4j.appender.appenderName.layout = fully.qualified.name.of.layout.classorg.apache.log4j.HTMLLayout（以HTML表格形式布局）org.apache.log4j.PatternLayout（可以灵活地指定布局模式）org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别) 4.控制台选项 RollingFileAppender 选项Threshold=DEBUG:指定日志消息的输出最低层次ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出File=mylog.txt:指定消息输出到mylog.txt文件Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件MaxBackupIndex=2:指定可以产生的滚动文件的最大数。log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n 5.日志信息格式中几个符号所代表的含义 -X号: X信息输出时左对齐；%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921%r: 输出自应用启动到输出该log信息耗费的毫秒数%c: 输出日志信息所属的类目，通常就是所在类的全名%t: 输出产生该日志事件的线程名%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。%%: 输出一个”%”字符%F: 输出日志消息产生时所在的文件名称%L: 输出代码中的行号%m: 输出代码中指定的消息,产生的日志具体信息%n: 输出一个回车换行符，Windows平台为”/r/n”，Unix平台为”/n”输出日志信息换行 可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。 1) %20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐2) %-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-“号指定左对齐3) %.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格4) %20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉]]></content>
      <categories>
        <category>开发π</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2020%2F09%2F26%2Fjava-idea-hot-key%2F</url>
    <content type="text"><![CDATA[常用快捷键1234567891011121314151617Ctrl＋E #显示最近编辑的⽂件列表Shift＋Click #关闭⽂件Ctrl＋[ ] #跳到⼤括号的开头结尾Ctrl＋Shift＋Backspace #跳转到上次编辑的地⽅Ctrl＋F12 #显示当前⽂件的结构Ctrl＋F7 #查询当前元素在当前⽂件中的引⽤，然后按F3可以选择Ctrl＋N #快速打开类Ctrl＋Shift＋N #快速打开⽂件Alt＋Q #看到当前⽅法的声明Ctrl＋W #选择单词继⽽语句继⽽⾏继⽽函数Alt＋F1 #将正在编辑的元素在各个⾯板中定位Ctrl＋P #显示参数信息Ctrl＋Shift＋Insert #选择剪贴板内容并插⼊Alt＋Insert #⽣成构造器/Getter/Setter等Ctrl＋Alt＋V #引⼊变量。例如把括号内的SQL赋成⼀个变量Ctrl＋Alt＋T #把代码包在⼀块内，例如try/catchAlt＋Up/Down #⽅法间快速移动 基本快捷键1234567891011121314151617181920212223242526272829303132333435363738Ctrl+G #跳转到指定⾏Ctrl+F4 #关闭当前编辑⻚⾯Ctrl+F #搜索Alt+回⻋ #导⼊包,⾃动修正Ctrl+N #查找类Ctrl+Shift+N #查找⽂件Ctrl+Alt+L #格式化代码Ctrl+Alt+O #优化导⼊的类和包Alt+Insert #⽣成代码(如get,set⽅法,构造函数等)Ctrl+E或者Alt+Shift+C #最近更改的代码Ctrl+R #替换⽂本Ctrl+F #查找⽂本Ctrl+Shift+Space #⾃动补全代码Ctrl+空格 #代码提示Ctrl+Alt+Space #类名或接⼝名提示Ctrl+P #⽅法参数提示Ctrl+Shift+Alt+N #查找类中的⽅法或变量Alt+Shift+C #对⽐最近修改的代码Shift+F6 #重构-重命名Ctrl+X #删除⾏Ctrl+D #复制⾏Ctrl+/ 或 Ctrl+Shift+/ #注释（// 或者/…/ ）Ctrl+J #⾃动代码Ctrl+E #最近打开的⽂件Ctrl+H #显示类结构图Ctrl+Q #显示注释⽂档Alt+F1 #查找代码所在位置Alt+1 #快速打开或隐藏⼯程⾯板Ctrl+Alt+left/right #返回⾄上次浏览的位置Alt+left/right #切换代码视图Alt+Up/Down #在⽅法间快速移动定位Ctrl+Shift+Up/Down #代码向上/下移动。F2或Shift+F2 #⾼亮错误或警告快速定位Ctrl+Shift+F7 #选中⽂本，⾼亮显示所有该⽂本，按Esc⾼亮消失。Ctrl+W #选中代码，连续按会有其他效果选中⽂本，按Alt+F3 ， #逐个往下查找相同⽂本，并⾼亮显示。Ctrl+Up/Down #光标跳转到第⼀⾏或最后⼀⾏下Ctrl+B #快速打开光标处的类或⽅法 查询快捷键123456789101112131415161718CTRL+N #查找类CTRL+SHIFT+N #查找⽂件CTRL+SHIFT+ALT+N #查找类中的⽅法或变量CIRL+B #找变量的来源CTRL+ALT+B #找所有的⼦类CTRL+SHIFT+B #找变量的类CTRL+G #定位⾏CTRL+F #在当前窗⼝查找⽂本CTRL+SHIFT+F #在指定窗⼝查找⽂本CTRL+R #在当前窗⼝替换⽂本CTRL+SHIFT+R #在指定窗⼝替换⽂本ALT+SHIFT+C #查找修改的⽂件CTRL+E #最近打开的⽂件F3 #向下查找关键字出现位置SHIFT+F3 #向上⼀个关键字出现位置F4 #查找变量来源CTRL+ALT+F7 #选中的字符查找⼯程出现的地⽅CTRL+SHIFT+O #弹出显示查找内容 自动代码123456789101112ALT+回⻋ #导⼊包,⾃动修正CTRL+ALT+L #格式化代码CTRL+ALT+I #⾃动缩进CTRL+ALT+O #优化导⼊的类和包ALT+INSERT #⽣成代码(如GET,SET⽅法,构造函数等)CTRL+E #最近更改的代码CTRL+SHIFT+SPACE #⾃动补全代码CTRL+空格 #代码提示CTRL+ALT+SPACE #类名或接⼝名提示CTRL+P #⽅法参数提示CTRL+J #⾃动代码CTRL+ALT+T #把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; ⾥ 复制快捷方式12CTRL+D #复制⾏CTRL+X #剪切,删除⾏ 其他快捷方式1234567891011121314151617181920212223CIRL+U #⼤⼩写切换CTRL+Z #倒退CTRL+SHIFT+Z #向前CTRL+ALT+F12 #资源管理器打开⽂件夹ALT+F1 #查找⽂件所在⽬录位置SHIFT+ALT+INSERT #竖编辑模式CTRL+/ #注释//CTRL+SHIFT+/ #注释/…/CTRL+W #选中代码，连续按会有其他效果CTRL+B #快速打开光标处的类或⽅法ALT+ ←/! #切换代码视图CTRL+ALT ←/! #返回上次编辑的位置ALT+ ↑/“ #在⽅法间快速移动定位SHIFT+F6 #重构-重命名CTRL+H #显示类结构图CTRL+Q #显示注释⽂档ALT+1 #快速打开或隐藏⼯程⾯板CTRL+SHIFT+UP/DOWN #代码向上/下移动。CTRL+UP/DOWN #光标跳转到第⼀⾏或最后⼀⾏ESC #光标返回编辑框SHIFT+ESC #光标返回编辑框,关闭⽆⽤的窗⼝F1 #帮助CTRL+F4 #关闭 不常用快捷键123456789101112Ctrl＋Shift＋Alt＋N #可以快速打开符号Ctrl＋Shift＋Space #在很多时候都能够给出Smart提示Alt＋F3 #可以快速寻找Ctrl＋/和Ctrl＋Shift＋/ #可以注释代码Ctrl＋Alt＋B #可以跳转到抽象⽅法的实现Ctrl＋O #选择⽗类的⽅法进⾏重写Ctrl＋Q #JavaDocCtrl＋Alt＋Space #是类名⾃动完成Ctrl＋Shift＋F7 #⾼亮当前元素在当前⽂件中的使⽤Ctrl＋Alt＋Up/Down #快速跳转搜索结果Ctrl＋Shift＋J #整合两⾏Alt＋F8 #计算变量值]]></content>
      <categories>
        <category>开发π</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse Java注释模板设置详解以及版权声明]]></title>
    <url>%2F2020%2F09%2F26%2Feclipse-template%2F</url>
    <content type="text"><![CDATA[文件(Files)注释标签编辑注释模板的方法：Window-&gt;Preference-&gt;Java-&gt;Code Style-&gt;Code Template 然后展开Comments节点就是所有需设置注释的元素啦。现就每一个元素逐一介绍：123456789/*** All rights Reserved, Designed By www.bt0a.com* @Title: $&#123;file_name&#125;* @Package $&#123;package_name&#125;* @Description: $&#123;todo&#125;(⽤⼀句话描述该⽂件做什么)* @author: zcc* @date: $&#123;date&#125; $&#123;time&#125;* @version V1.0* 类型(Types)注释标签（类的注释）1234567/*** @ClassName: $&#123;type_name&#125;* @Description:$&#123;todo&#125;(这⾥⽤⼀句话描述这个类的作⽤)* @author: zcc* @date: $&#123;date&#125; $&#123;time&#125;* $&#123;tags&#125;*/ 字段(Fields)注释标签123456/*** @Title: $&#123;enclosing_type&#125;* @Description: $&#123;todo&#125;(这⾥⽤⼀句话描述这个⽅法的作⽤)* @param: $&#123;tags&#125;* @throws*/ 方法(Methods)标签1234567/*** @Title: $&#123;enclosing_method&#125;* @Description: $&#123;todo&#125;(这⾥⽤⼀句话描述这个⽅法的作⽤)* @param: $&#123;tags&#125;* @return: $&#123;return_type&#125;* @throws*/ 覆盖方法(Overriding Methods)标签123456/*** &lt;p&gt;Title: $&#123;enclosing_method&#125;&lt;/p&gt;* &lt;p&gt;Description: &lt;/p&gt;* $&#123;tags&#125;* $&#123;see_to_overridden&#125;*/ 代表方法(Delegate Methods)标签1234/*** $&#123;tags&#125;* $&#123;see_to_target&#125;*/ getter方法标签12345/*** @Title: $&#123;enclosing_method&#125; &lt;BR&gt;* @Description: please write your description &lt;BR&gt;* @return: $&#123;field_type&#125; &lt;BR&gt;*/ setter方法标签12345/*** @Title: $&#123;enclosing_method&#125; &lt;BR&gt;* @Description: please write your description &lt;BR&gt;* @return: $&#123;field_type&#125; &lt;BR&gt;*/]]></content>
      <categories>
        <category>开发π</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse 快捷键]]></title>
    <url>%2F2020%2F09%2F26%2Feclipse-hotkey%2F</url>
    <content type="text"><![CDATA[编辑12345678910111213141516Ctrl+1 #快速修复Ctrl+. #定位到错误点Ctrl+Shift+F #格式化当前代码Ctrl+Shift+M #添加类的import导⼊Ctrl+Shift+O #组织类的import导⼊Ctrl+Y #重做（与撤销Ctrl+Z相反）Ctrl+D #删除当前⾏或者多⾏Alt+! #当前⾏和下⾯⼀⾏交互位置Alt+↑ #当前⾏和上⾯⼀⾏交互位置（同上）Ctrl+Alt+! #复制当前⾏到下⼀⾏（复制增加）Ctrl+Alt+↑ #复制当前⾏到上⼀⾏（复制增加）Shift+Enter #在当前⾏的下⼀⾏插⼊空⾏Ctrl+shift+enter #在当前⾏之前插⼊空⽩⾏Ctrl+/ #注释当前⾏,再按则取消注释Ctrl+shift+x #英⽂字⺟⼤⼩写的转换Ctrl+Q #定位到最后编辑的地⽅ 选择1234567Alt+Shift+↑ #选择封装元素Alt+Shift+← #选择上⼀个元素Alt+Shift+" #选择下⼀个元素Shift+← #从光标处开始往左选择字符Shift+" #从光标处开始往右选择字符Ctrl+Shift+← #选中光标左边的单词Ctrl+Shift+" #选中光标右边的单词 移动12Ctrl+← #光标移到左边单词的开头，相当于vim的bCtrl+" #光标移到右边单词的末尾，相当于vim的e 搜索123456789Ctrl+K #参照选中的Word快速定位到下⼀个Ctrl+Shift+K #参照选中的Word快速定位到上⼀个Ctrl+J #正向增量查找Ctrl+Shift+J #反向增量查找（和上条相同,只不过是从后往前查）Ctrl+Shift+U #列出所有包含字符串的⾏Ctrl+H #打开搜索对话框Ctrl+G #⼯作区中的声明Ctrl+Shift+G #⼯作区中的引⽤Ctrl+Alt+H #类的⽅法到底被那些其他的类调⽤ 导航12345678910Ctrl+Shift+T #搜索类（包括⼯程和关联的第三jar包）Ctrl+Shift+R #搜索⼯程中的⽂件Ctrl+E #快速显示当前Editer的下拉列表（如果当前⻚⾯没有显示的⽤⿊体表示）Ctrl+F3 #打开结构F4 #打开类型层次结构F3 #跳转到声明处Alt+← #前⼀个编辑的⻚⾯Alt+" #下⼀个编辑的⻚⾯（当然是针对上⾯那条来说了）Ctrl+PageUp/PageDown #在编辑器中，切换已经打开的⽂件Ctrl+Shift+H #在层次结构中打开类型 调试123456789F5 #单步跳⼊F6 #单步跳过F7 #单步返回F8 #继续⼀直执⾏到下⼀个断点Ctrl+F5 #单步跳⼊选择F11 #调试上次启动Ctrl+Shift+D #显示变量的值Ctrl+Shift+B #在当前⾏设置或者去掉断点Ctrl+R #运⾏⾄⾏(超好⽤，可以节省好多的断点) 重构12345678Alt+Shift+R #重命名⽅法名、属性或者变量名Alt+Shift+M #把⼀段函数内的代码抽取成⽅法Alt+Shift+C #修改函数结构Alt+Shift+L #抽取本地变量Alt+Shift+F #把Class中的local变量变为field变量 （⽐较实⽤的功能）Alt+Shift+I #合并变量（可能这样说有点不妥Inline）Alt+Shift+V #移动函数和变量（不怎么常⽤）Alt+Shift+Z #重构的后悔药（Undo） 其他123456789Alt+Enter #显示当前选择资源的属性Ctrl+↑ #⽂本编辑器 上滚⾏Ctrl+! #⽂本编辑器 下滚⾏Ctrl+M #最⼤化当前的Edit或ViewCtrl+O #快速显示Ctrl+T #快速显示当前类的继承结构Ctrl+W #关闭当前EditerCtrl+L #⽂本编辑器 转⾄⾏F2 #显示⼯具提示描]]></content>
      <categories>
        <category>开发π</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[txt2Excel.py]]></title>
    <url>%2F2020%2F09%2F24%2Ftxt2Excel%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!usr/bin/env python # -*- coding: utf-8 -*-"""@author: oje@file: txt2Excel.py@time: 2017/8/30 20:24"""#xlrd是读excel，xlwt是写excel的库import xlwtimport osfrom tempfile import NamedTemporaryFilew = xlwt.Workbook()ws = w.add_sheet('sheet1', cell_overwrite_ok=True)input_txt_path = input("请输入文件名:\n")+".txt"count = 0sheet_x = 0output_excel_path = ''if os.path.exists(input_txt_path): output_excel_path = input("文件存在,请输入输出文件名称:\n") + ".xls"else: print('文件不存在...') exit()with open(input_txt_path, "r", encoding='utf-8') as txt_f: with NamedTemporaryFile('w+t', delete=False, encoding='utf-8') as tmp_f: for txt_line in txt_f: tmp_f.write(txt_line.replace('%', '%\n')) with open(tmp_f.name, "r", encoding='utf-8') as tmp_line: for ex in tmp_line: if ex[0:1] == "A": mv_android = str(int(ex[8:12])/1000) name_android = ex[0:8] mv_k21 = ex[21:25] name_k21 = ex[17:21] ws.write(sheet_x, 3, mv_android) ws.write(sheet_x, 2, name_android) ws.write(sheet_x, 5, mv_k21) ws.write(sheet_x, 4, name_k21) elif ex[0:1] == "2": time = ex[:] ws.write(sheet_x, 0, time) elif ex[0:1] == "电": power = ex[5:].replace('%\n', '') ws.write(sheet_x, 1, power) count += 1 if count == 3: count = 0 sheet_x += 1w.save(output_excel_path)]]></content>
      <categories>
        <category>Codeπ</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构]]></title>
    <url>%2F2018%2F04%2F02%2Flinux-directory-tree%2F</url>
    <content type="text"><![CDATA[可分享的(shareable) 不可分享的(unshareable) 不变的(static) /usr (软件放置处) /etc (配置文件) 不变的(static) /opt (第三方协力软件) /boot (开机与核心档) 可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关) 可变动的(variable) /var/spool/news (新闻组) /var/lock (程序相关) 四种类型 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录； 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义： / (root, 根目录)：与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /var (variable)：与系统运作过程有关。 根目录 (/) 的意义与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的,同时根目录也与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区，因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。根据以上原因，FHS认为根目录(/)下应该包含如下子目录 目录 应放置档案内容 /bin 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 /etc 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /media media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： 目录 应放置档案内容 /lost+found 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 /usr 的意义与内容依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： 目录 应放置档案内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件,/usr/share/doc：软件杂项的文件说明,/usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： 目录 应放置档案内容 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/ 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/ 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/ 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 目录树(directory tree)在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示： 绝对路径与相对路径除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？命令：12cd /var/log (absolute)cd ../var/log (relative) 因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？命令： cd /var/spool/mail cd ../cron 说明：由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明：由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie参数简介]]></title>
    <url>%2F2018%2F04%2F01%2Fweb-cookie%2F</url>
    <content type="text"><![CDATA[参数 简介 Domain 设置关联cookie的域名 Expires 通过给定一个过期时间来创建一个持久化cookie httponly 避免cookie被js访问 name cookie名称 path 关联到cookie的路径，默认为 / value 值 secure 用于指定cookie需要通过安全socket曾连接传递]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite组件简介]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-burpsuite%2F</url>
    <content type="text"><![CDATA[组件 简介 Proxy 是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许拦截，查看，修改在两个方向上的原始数据流 Spider 是一个应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能 Scanner 是一个高级的工具，执行后，它能自动地发现web 应用程序的安全漏洞 Intruder 是一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞 Repeater 是一个靠手动操作来补发单独的HTTP 请求，并分析应用程序响应的工具 Sequencer 是一个用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具 Decoder 是一个进行手动执行或对应用程序数据者智能解码编码的工具 Comparer 是一个实用的工具，通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[一般模式123456789101112131415x,X x为向后删除一个字符，X为先前删除一个字符nx(n代表数字) 向后删除n个字符dd 删除当前行D 删除当前行所有字符，试成为空行ndd(n代表数字) 删除光标所在行的向下n列d1G 删除光标所在行到第一行的所有数据dG 删除光标所在行到最后一行的所有数据yy 复制光标所在行y1G 复制光标所在行到第一行的所有数据yG 复制光标所在行到最后一行的所有数据ynj(n代表数字) 复制光标所在行向下n+1行dnj(n代表数字) 删除光标所在行向下n+1行p,P p为复制的数据粘贴在光标的下一行，P为复制的数据粘贴在光标的上一行J 将光标所在行与下一行的数据结合成一行u 恢复前一个动作(undo) 编辑模式123456i,I i为在当前光标所在处插入输入的文字，I为在光标所在行第一个非空字符插入输入的文字a,A a为在当前光标所在处下一个字符插入输入的文字，A为在光标所在行 最后一个字符的下一个字符处插入输入的文字o,O o为在光标所在行的下一行行首开始插入字符，O为在光标所在行的上一行行首开始插入字符r,R r为替换光标所在那一个字符，R为一直替换光标所指的文字，直到退出Esc 退出，回到一般模式 命令模式12345678910111213141516171819202122232425262728293031323334h 光标向左移一个字符j 光标向下移一个字符k 光标向上移一个字符l 光标向右移一个字符Ctrl+f 屏幕向下翻一页Ctrl+b 屏幕向上翻一页Ctrl+d 屏幕向下翻半页Ctrl+u 屏幕向上翻半页+ 光标移动到下一行的第一个非空字符- 光标移动到当前行的第一个非空字符n空格(n代表数字) 光标向当前行向右移动n个字符0(数字0) 光标移动到当前行的第一个字符(可以为空字符,注意与-区分）$ 光标移动到当前行的最后一个字符(可以为空字符,注意与-区分）H 光标移动到当前屏幕最上方的那一行的第一个非空字符M 光标移动到当前屏幕最中间那一行的第一个非空字符L 光标移动到当前屏幕最下方的那一行的第一个非空字符G 光标移动到该文章最后一行的第一个非空字符nG(n代表数字) 光标移动到该文章第n行的第一个非空字符n 光标从当前行向下移动n行的第一个非空字符/word 在光标之后查找word字符串?word 在光标之前查找word字符串:s/word1/word2/g 在光标当前行查找word1，并替换成word2:n1,n2s/word1/word2/g 在第n1行与第n2行之间查找word1，并替换成word2:%s/word1/word2/g 整个文章查找word1，并替换成word2:w 将编辑的数据保存到硬盘文件中:w [filename] 将编辑后的数据保存到硬盘的另一个文件中:r [filename] 在编辑数据时，读入另一个文件中的数据， 即将filename文件中的内容加到光标所在行下一行:wq或:x 保存并退出:q 退出，适用于未修改的文件:q! 强制退出，适用于修改文件后不保存退出:set nu 显示行号:set nonu 取消行号:n1,n2 w [filename] 将n1到n2行的内容保存到名为filename的文件中]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu设置应用在后台运行服务]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-bakcgroup%2F</url>
    <content type="text"><![CDATA[12345678910111213141516# 方法一:$ setsid python xxx.py &gt;log.txt$ ps -aux $ ps -ef |grep run.py$ kill -9 [PID]# 方法二:$ nohup python run.py &gt;log.txt# 将打印内容重定向到/dev/null中，相当于直接丢弃，任何地方都找不到打印的内容$ python your_script.py &gt;&gt; /dev/null # 如果又要查看打印的内容，怎么让它输出(还在运行)？# 将输出重定向到当前目录下的log.txt文件中$ python your_script.py &gt;&gt; log.txt$ cat log.txt # 查看截止目前所有的日志内容$ tail log.txt # 查看截止目前，最后10行日志$ tail -f log.txt # 从最后10行开始滚动输出，准实时刷新$ tail -n 100 -f log.txt # 从最后100行开始滚动输出]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS clean boot]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-clean-boot%2F</url>
    <content type="text"><![CDATA[12345678# 1.使用如下命令查询目前安装在系统里的全部内核（kernel）$ rpm -q kernel# 2.查询当前使用的内核（kernel）版本$ uname -a# 3.删除除当前内核以外所有的内核$ rpm -e '内核版本号'$ rpm -e kernel-2.6.32-358.el6.i686# 4.使用命令df -h 查看/boot分区的使用情况。]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2018%2F04%2F01%2Fmaven%2F</url>
    <content type="text"><![CDATA[基础命令12345678910111213141516171819202122232425262728293031323334# 1.创建Maven的普通java项目$ mvn archetype:create -DgroupId=packageName -DartifactId=projectName # 2.创建Maven的Web项目$ mvn archetype:create -DgroupId=packageName -DartifactId= webappName-DarchetypeArtifactId=maven-archetype-webapp # 3.编译源代码： $ mvn compile # 4.编译测试代码：$ mvn test-compile # 5.运行测试：$ mvn test # 6.产生site：$ mvn site # 7.打包：$ mvn package # 8.在本地Repository中安装jar：$ mvn install # 9.清除产生的项目：$ mvn clean # 10.生成eclipse项目：$ mvn eclipse:eclipse # 11.生成idea项目：$ mvn idea:idea # 12.组合使用goal命令，如只打包不测试：$ mvn -Dtest package # 13.编译测试的内容：$ mvn test-compile # 14.只打jar包: $ mvn jar:jar # 15.只测试而不编译，也不测试编译：$ mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) # 16.清除eclipse的一些系统设置:$ mvn eclipse:clean 热更新及常用命令12345678910111213141516171819202122232425262728293031321、在tomcat的安装⽬录下,修改conf/tomcat-user.xml⽂件,在&lt;tomcat-users&gt;节点下⾯增加如下配置:#web访问 http://192.168.7.140:8080/manager'&lt;role rolename="manager-gui" /&gt;&lt;role rolename="manager-script" /&gt;&lt;user username="tomcat" password="tomcat" roles="manager-gui, manager-script"/&gt;'2、修改项⽬的pom.xml⽂件,在&lt;build&gt; 节点下⾯增加如下配置:tomcat7的配置'&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8084&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;url&gt;http://192.168.7.140:8080/manager/text&lt;/url&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;'3、热部署命令'clean tomcat7:redeploy -DskipTests'4、常⽤命令clean tomcat7:runinstall -DskipTestsclean tomcat7:redeploy -DskipTests 源更换123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; pom.xml1234567891011121314151617181920&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; # snapshot 快照 # alpha 内部测试 # beta 公测 # release 稳定 # GA 正式发布&lt;packaging&gt;jar&lt;/packaging&gt; #war zip pom &lt;profile&gt; &lt;id&gt;jdk1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; ​]]></content>
      <categories>
        <category>开发π</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础命令]]></title>
    <url>%2F2018%2F04%2F01%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[1234567891011121314# 镜像$ docker images # 查看镜像$ docker pull$ docker inspect id # 详细信息$ docker search XXX # 搜索$ docker rmi XXX # 删除$ docker ps -a # 查看所有容器$ docker commit -a 作者 -m提交信息 -p 提交时暂停容器运行$ docker save -o ubuntu_14.04.tar ubuntu:14.04 # 存出镜像$ docker load &lt;ubuntu_14.04.tar # 载入镜像# 容器$ docker create it XXX # 新建容器$ docker run $ docker stop]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-command%2F</url>
    <content type="text"><![CDATA[文件/文件夹管理12345678910111213$ ls # 列出当前目录文件（不包括隐含文件） $ ls -a # 列出当前目录文件（包括隐含文件） $ ls -l # 列出当前目录下文件的详细信息 $ cd .. # 回当前目录的上一级目录 $ cd - # 回上一次所在的目录 $ cd ~ 或 cd # 回当前用户的宿主目录 $ mk 目录名 # 创建一个目录 $ rmdir 空目录名 # 删除一个空目录 $ rm 文件名 文件名 # 删除一个文件或多个文件 $ rm -rf 非空目录名 # 删除一个非空目录下的一切 $ mv 路经/文件 # /路经/文件移动相对路经下的文件到绝对路经下 $ mv 文件名 新名称 # 在当前目录下改名 $ find 路经 -name “字符串” # 查找路经所在范围内满足字符串匹配的文件和目录 系统管理123456789101112131415161718192021222324252627$ fdisk fdisk -l # 查看系统分区信息 $ fdisk fdisk /dev/sdb # 为一块新的SCSI硬盘进行分区 $ chown chown root /home # 把/home的属主改成root用户 $ chgrp chgrp root /home # 把/home的属组改成root组 $ Useradd # 创建一个新的用户 $ Groupadd 组名 # 创建一个新的组 $ Passwd 用户名 # 为用户创建密码 $ Passwd -d用户名 # 删除用户密码也能登陆 $ Passwd -S用户名 # 查询账号密码 $ Usermod -l 新用户名 老用户名 # 为用户改名 $ Userdel–r 用户名 # 删除用户一切 $ service [servicename] start/stop/restart # 系统服务控制操作 $ /etc/init.d/[servicename] start/stop/restart # 系统服务控制操作 $ uname -a # 查看内核版本 $ cat /etc/issue # 查看ubuntu版本 $ lsusb # 查看usb设备 $ sudo ethtool eth0 # 查看网卡状态 $ cat /proc/cpuinfo # 查看cpu信息 $ lshw # 查看当前硬件信息 $ sudo fdisk -l # 查看磁盘信息 $ df -h # 查看硬盘剩余空间 $ free -m # 查看当前的内存使用情况 $ ps -A # 查看当前有哪些进程 $ kill # 进程号(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程) $ kill -9 进程号 # 强制杀死一个进程 $ reboot Init 6 # 重启LINUX系统 $ Halt Init 0 Shutdown –h now # 关闭LINUX系统 打包/解压12345$ tar -c 创建包 –x 释放包 -v 显示命令过程 –z 代表压缩包 $ tar –cvf benet.tar /home/benet # 把/home/benet目录打包 $ tar –zcvf benet.tar.gz /mnt # 把目录打包并压缩 $ tar –zxvf benet.tar.gz # 压缩包的文件解压恢复 $ tar –jxvf benet.tar.bz2 # 解压缩 make编译12$ make # 编译 $ make install # 安装编译好的源码包 apt命令123456789101112131415161718$ apt-cache search package # 搜索包 $ apt-cache show package # 获取包的相关信息，如说明、大小、版本等 $ sudo apt-get install package # 安装包 $ sudo apt-get install package - - reinstall # 重新安装包 $ sudo apt-get -f install # 修复安装”-f = –fix-missing” $ sudo apt-get remove package # 删除包 $ sudo apt-get remove package - - purge # 删除包，包括删除配置文件等 $ sudo apt-get update # 更新源 $ sudo apt-get upgrade # 更新已安装的包 $ sudo apt-get dist-upgrade # 升级系统 $ sudo apt-get dselect-upgrade # 使用 dselect 升级 $ apt-cache depends package # 了解使用依赖 $ apt-cache rdepends package # 是查看该包被哪些包依赖 $ sudo apt-get build-dep package # 安装相关的编译环境 $ apt-get source package # 下载该包的源代码 $ sudo apt-get clean &amp;&amp; sudo apt-get autoclean # 清理无用的包 $ sudo apt-get check # 检查是否有损坏的依赖 $ sudo apt-get clean # 清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-command%2F</url>
    <content type="text"><![CDATA[关机 (系统的关机、重启以及登出 )的命令12345678$ shutdown -h now # 关闭系统(1) $ init 0 # 关闭系统(2) $ telinit 0 # 关闭系统(3) $ shutdown -h hours:minutes # 按预定时间关闭系统 $ shutdown -c # 取消按预定时间关闭系统 $ shutdown -r now # 重启(1) $ reboot # 重启(2) $ logout # 注销 文件和目录1234567891011121314151617181920212223242526$ cd /home # 进入 '/ home' 目录$ cd .. # 返回上一级目录 $ cd ../.. # 返回上两级目录 $ cd # 进入个人的主目录 $ cd ~user1 # 进入个人的主目录 $ cd - # 返回上次所在的目录 $ pwd # 显示工作路径 $ ls # 查看目录中的文件 $ ls -F # 查看目录中的文件 $ ls -l # 显示文件和目录的详细资料 $ ls -a # 显示隐藏文件 $ mkdir dir1 # 创建一个叫做 'dir1' 的目录$ mkdir dir1 dir2 # 同时创建两个目录 $ mkdir -p /tmp/dir1/dir2 # 创建一个目录树 $ rm -f file1 # 删除一个叫做 'file1' 的文件' $ rmdir dir1 # 删除一个叫做 'dir1' 的目录' $ rm -rf dir1 # 删除一个叫做 'dir1' 的目录并同时删除其内容 $ rm -rf dir1 dir2 # 同时删除两个目录及它们的内容 $ mv dir1 new_dir # 重命名/移动 一个目录 $ cp file1 file2 # 复制一个文件 $ cp dir/* . # 复制一个目录下的所有文件到当前工作目录 $ cp -a /tmp/dir1 . # 复制一个目录到当前工作目录 $ cp -a dir1 dir2 # 复制一个目录 $ ln -s file1 lnk1 # 创建一个指向文件或目录的软链接 $ ln file1 lnk1 # 创建一个指向文件或目录的物理链接 $ touch file1 # 创建一个文件 文件搜索命令123456789101112131415$ find / -name file1 # 从 '/' 开始进入根文件系统搜索文件和目录 $ find / -user user1 # 搜索属于用户 'user1' 的文件和目录 # 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 $ find /home/user1 -name \*.bin $ find /usr/bin -type f -atime +100 # 搜索在过去100天内未被使用过的执行文件 $ find /usr/bin -type f -mtime -10 # 搜索在10天内被创建或者修改过的文件 $ locate \*.ps # 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 $ whereis file # 显示一个二进制文件、源码或man的位置 $ which file # 显示一个二进制文件或可执行文件的完整路径 # 在当前目录及其子目录所有.c和.h文件中查找 'expr'$ find -name '*.[ch]' | xargs grep -E 'expr' # 在当前目录及其子目录的常规文件中查找 'expr'$ find -type f -print0 | xargs -r0 grep -F 'expr' # 在当前目录中查找 'expr'$ find -maxdepth 1 -type f | xargs grep -F 'expr' 查看文件内容123456$ cat file1 # 从第一个字节开始正向查看文件的内容 $ tac file1 # 从最后一行开始反向查看一个文件的内容 $ more file1 # 查看一个长文件的内容 $ less file1 # 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 $ head -2 file1 # 查看一个文件的前两行 $ tail -2 file1 # 查看一个文件的最后两行 打包和解压缩文件123456789101112131415161718192021$ bunzip2 file1.bz2 # 解压一个叫做 'file1.bz2'的文件 $ bzip2 file1 # 压缩一个叫做 'file1' 的文件 $ gunzip file1.gz # 解压一个叫做 'file1.gz'的文件 $ gzip file1 # 压缩一个叫做 'file1'的文件 $ gzip -9 file1 # 最大程度压缩 $ rar a file1.rar test_file # 创建一个叫做 'file1.rar' 的包 $ rar a file1.rar file1 file2 dir1 # 打包 'file1', 'file2' 以及目录 'dir1' $ rar x file1.rar # 解rar包 $ unrar x file1.rar # 解rar包 $ tar -cvf archive.tar file1 # 创建一个非压缩的tar包 $ tar -cvf archive.tar file1 file2 dir1 # 创建一个包含了 'file1', 'file2' 'dir1'的包 $ tar -tf archive.tar # 显示一个包中的内容 $ tar -xvf archive.tar # 释放一个包 $ tar -xvf archive.tar -C /tmp # 将压缩包释放到 /tmp目录下 （-c是指定目录）$ tar -cvfj archive.tar.bz2 dir1 # 创建一个bzip2格式的压缩包 $ tar -xvfj archive.tar.bz2 # 解压一个bzip2格式的压缩包 $ tar -cvfz archive.tar.gz dir1 # 创建一个gzip格式的压缩包 $ tar -xvfz archive.tar.gz # 解压一个gzip格式的压缩包 $ zip file1.zip file1 # 创建一个zip格式的压缩包 $ zip -r file1.zip file1 file2 dir1 # 将几个文件和目录同时压缩成一个zip格式的压缩包 $ unzip file1.zip # 解压一个zip格式压缩包 磁盘空间操作的命令1234$ df -h # 显示已经挂载的分区列表 $ ls -lSr |more # 以尺寸大小排列文件和目录 $ du -sh dir1 # 估算目录 'dir1' 已经使用的磁盘空间$ du -sk * | sort -rn # 以容量大小为依据依次显示文件和目录的大小 RPM1234567891011121314151617181920212223242526272829$ rpm -ivh package.rpm # 安装一个rpm包 $ rpm -ivh --nodeeps package.rpm # 安装一个rpm包而忽略依赖关系警告 $ rpm -U package.rpm # 更新一个rpm包但不改变其配置文件 $ rpm -F package.rpm # 更新一个确定已经安装的rpm包 $ rpm -e package_name.rpm # 删除一个rpm包 $ rpm -qa # 显示系统中所有已经安装的rpm包 $ rpm -qa | grep httpd # 显示所有名称中包含 "httpd" 字样的rpm包 $ rpm -qi package_name # 获取一个已安装包的特殊信息 $ rpm -ql package_name # 显示一个已经安装的rpm包提供的文件列表 $ rpm -qc package_name # 显示一个已经安装的rpm包提供的配置文件列表 $ rpm -q package_name --whatrequires # 显示与一个rpm包存在依赖关系的列表 $ rpm -q package_name --whatprovides # 显示一个rpm包所占的体积 $ rpm -q package_name --scripts # 显示在安装/删除期间所执行的脚本l $ rpm -q package_name --changelog # 显示一个rpm包的修改历史 $ rpm -qf /etc/httpd/conf/httpd.conf # 确认所给的文件由哪个rpm包所提供 $ rpm -qp package.rpm -l # 显示由一个尚未安装的rpm包提供的文件列表 $ rpm --import /media/cdrom/RPM-GPG-KEY # 导入公钥数字证书 $ rpm --checksig package.rpm # 确认一个rpm包的完整性 $ rpm -qa gpg-pubkey # 确认已安装的所有rpm包的完整性 # 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 $ rpm -V package_name $ rpm -Va # 检查系统中所有已安装的rpm包- 小心使用 $ rpm -Vp package.rpm # 确认一个rpm包还未安装 # 从一个rpm包运行可执行文件 $ rpm2cpio package.rpm | cpio --extract --make-directories *bin* # 从一个rpm源码安装一个构建好的包 $ rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm # 从一个rpm源码构建一个 rpm 包 $ rpmbuild --rebuild package_name.src.rpm YUM1234567891011$ yum install package_name # 下载并安装一个rpm包 # 将安装一个rpm包使用你自己的软件仓库为你解决所有依赖关系 $ yum localinstall package_name.rpm $ yum update package_name.rpm # 更新当前系统中所有安装的rpm包 $ yum update package_name # 更新一个rpm包 $ yum remove package_name # 删除一个rpm包 $ yum list # 列出当前系统中安装的所有包 $ yum search package_name # 在rpm仓库中搜寻软件包 $ yum clean packages # 清理rpm缓存删除下载的包 $ yum clean headers # 删除所有头文件 $ yum clean all # 删除所有缓存的包和头文件 ​ 查看系统信息12345678910111213141516171819$ arch # 显示机器的处理器架构(1) $ uname -m # 显示机器的处理器架构(2) $ uname -r # 显示正在使用的内核版本 $ dmidecode -q # 显示硬件系统部件 - (SMBIOS / DMI) $ hdparm -i /dev/hda # 罗列一个磁盘的架构特性 $ hdparm -tT /dev/sda # 在磁盘上执行测试性读取操作 $ cat /proc/cpuinfo # 显示CPU info的信息 $ cat /proc/interrupts # 显示中断 $ cat /proc/meminfo # 校验内存使用 $ cat /proc/swaps # 显示哪些swap被使用 $ cat /proc/version # 显示内核的版本 $ cat /proc/net/dev # 显示网络适配器及统计 $ cat /proc/mounts # 显示已加载的文件系统 $ lspci -tv # 罗列 PCI 设备 $ lsusb -tv # 显示 USB 设备 $ date # 显示系统日期 $ cal 2007 # 显示2007年的日历表 $ date 041217002007.00 # 设置日期和时间 - 月日时分年.秒 $ clock -w # 将时间修改保存到 BIOS 挂载命令1234567891011121314151617# 挂载一个叫做hda2的盘 （注：确定目录 '/ mnt/hda2' 已经存在） $ mount /dev/hda2 /mnt/hda2 # 卸载一个叫做hda2的盘（先从挂载点 '/ mnt/hda2' 退出）$ umount /dev/hda2 # 当设备繁忙时强制卸载 $ fuser -km /mnt/hda2# 运行卸载操作而不写入 /etc/mtab 文件（当文件为只读或当磁盘写满时非常有用） $ umount -n /mnt/hda2 # $ mount /dev/fd0 /mnt/floppy # 挂载一个软盘 $ mount /dev/cdrom /mnt/cdrom # 挂载一个光盘$ mount /dev/hdc /mnt/cdrecorder # 挂载一个cdrw或dvdrom $ mount /dev/hdb /mnt/cdrecorder # 挂载一个cdrw或dvdrom $ mount -o loop file.iso /mnt/cdrom # 挂载一个文件或ISO镜像文件 $ mount -t vfat /dev/hda5 /mnt/hda5 # 挂载一个Windows FAT32文件系统 $ mount /dev/sda1 /mnt/usbdisk # 挂载一个usb 捷盘或闪存设备# 挂载一个windows网络共享 $ mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 用户和群组1234567891011121314151617181920212223242526272829303132$ groupadd group_name # 创建一个新用户组 $ groupdel group_name # 删除一个用户组 $ groupmod -n new_group_name old_group_name # 重命名一个用户组 # 创建一个属于 "admin" 用户组的用户 $ useradd -c "Name Surname " -g admin -d /home/user1 -s /bin/bash user1 $ useradd user1 # 创建一个新用户 $ userdel -r user1 # 删除一个用户 ( '-r' 同时删除除主目录) $ passwd user1 # 修改一个用户的口令 (只允许root执行) $ chage -E 2005-12-31 user1 # 设置用户口令的失效期限 $ ls -lh # 显示权限 # 设置目录的所有人(u)、群组(g)以及其他人(o)以读(r)、写(w)和执行(x)的权限 $ chmod 777 directory1# 删除群组(g)与其他人(o)对目录的读写执行权限 $ chmod 700 directory1 # 改变一个文件的所有人属性，为use1$ chown user1 file1 # 改变一个目录的所有人属性并同时改变改目录下所有文件的属性都为use1所有 $ chown -R user1 directory1 # 改变文件的群组为group1 $ chgrp group1 file1# 改变一个文件的所有人和群组属性，所属组为group1，用户为use1。 $ chown user1:group1 file1 # 罗列一个系统中所有使用了SUID控制的文件 $ find / -perm -u+s # 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 $ chmod u+s /bin/file1 # 禁用一个二进制文件的 SUID位 $ chmod u-s /bin/file1 $ chmod g+s /home/public # 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 $ chmod g-s /home/public # 禁用一个目录的 SGID 位 $ chmod o+t /home/public # 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 $ chmod o-t /home/public # 禁用一个目录的 STIKY 位]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS端口]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-port%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334# 查看80端口占用$ lsof -i tcp:80# 列出所有端口$ netstat -ntlp# 开启端口（以80端口为例）# 方法一：$ /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT # 写入修改$ /etc/init.d/iptables save # 保存修改$ service iptables restart # 重启防火墙，修改生效# 方法二：$ vi /etc/sysconfig/iptables # 打开配置文件加入如下语句:-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT # 重启防火墙，修改完成# 关闭端口# 方法一：$ /sbin/iptables -I INPUT -p tcp --dport 80 -j DROP # 写入修改$ /etc/init.d/iptables save # 保存修改$ service iptables restart # 重启防火墙，修改生效# 方法二：$ vi /etc/sysconfig/iptables #打开配置文件加入如下语句:-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j DROP # 重启防火墙，修改完成# 查看端口状态$ /etc/init.d/iptables status# 查询防火墙状态:$ service iptables status# 停止防火墙:$ service iptables stop # 启动防火墙:$ service iptables start # 重启防火墙:$ service iptables restart # 永久关闭防火墙:$ chkconfig iptables off # 永久关闭后启用:$ chkconfig iptables on]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS无法上网问题]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-network%2F</url>
    <content type="text"><![CDATA[1234$ cd /etc/sysconfig/network-scripts/# ls 查看一下ifcfg-eno后面对应的数字是什么，以eno32为例$ vim ifcfg-eno32 # 设置ONBOOT=yes 即开启自动启用网络连接$ service network restart 重启网络]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Git升级]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-git-update%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617# 安装编译git时需要的包$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum install gcc perl-ExtUtils-MakeMaker# 删除已有的git$ yum remove git# 下载git源码$ cd /usr/src$ wget https://www.kernel.org/pub/software/scm/git/git-2.0.5.tar.gz$ tar xzf git-2.0.5.tar.gz# 编译安装$ cd git-2.0.5$ make prefix=/usr/local/git all$ make prefix=/usr/local/git install$ echo "export PATH=$PATH:/usr/local/git/bin" &gt;&gt; /etc/bashrc$ source /etc/bashrc# 检查一下版本号$ git --version]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS yum,npm源更换]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-centos-yum-npm%2F</url>
    <content type="text"><![CDATA[12345678# yum源更换# 备份$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup$ cd /etc/yum.repos.d/ ​$ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo# 生成缓存：$ yum clean all$ yum makecache ​ 1234567# npm源更换$ alias cnpm="npm --registry=https://registry.npm.taobao.org \--cache=$HOME/.npm/.cache/cnpm \--disturl=https://npm.taobao.org/dist \--userconfig=$HOME/.cnpmrc" ​# npm升级$ npm update npm ​]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB常用命令]]></title>
    <url>%2F2018%2F04%2F01%2Fandriod-adb%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728# 查看设备$ adb devices # 安装apk$ adb install -r &lt;package&gt; # 卸载apk$ adb uninstall &lt;package&gt; # 安装应用到指定应用$ adb -s 设备号 install xxx.apk # 从模拟器或手机中复制一个文件或文件夹（递归的）使用：$ adb pull &lt;remote&gt; &lt;local&gt;# 复制一个文件或文件夹（递归的）到模拟器或手机中使用：$ adb push &lt;local&gt; &lt;remote&gt;# 在这个命令中和引用的是文件或文件夹的路径，# 在开发用电脑上的是local，在模拟器或手机上的是remote# 启动adb server$ adb start-server # 停止adb server$ adb kill-server # 列出系统应用的所有包名：$ adb shell pm list packages -s# 列出除了系统应用的第三方应用包名：$ adb shell pm list packages -3# 使用 grep 来过滤：$ adb shell pm list packages | grep qq# 清除应用数据与缓存$ adb shell pm clear &lt;packagename&gt;# 启动应用$ adb shell am start -n 包名/类名]]></content>
      <categories>
        <category>Androidπ</category>
      </categories>
      <tags>
        <tag>ADB</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Airmon-ng简要操作]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-kali-airmon-ng%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718$ airmon-ng check kill # 杀进程$ airmon-ng start wlan0 # 启动无效网卡$ airodump-ng wlan0mon # 探测# 抓包$ airodump-ng --bssid XX:XX:XX:XX:XX:XX -c 1 -w testap wlan0mon --bssid 是路由器的mac地址 -w 是写入到文件longas中 -c 11 是频道11# 攻击$ aireplay-ng -0 0 -a XX:XX:XX:XX:XX:XX -c XX:XX:XX:XX:XX:XX wlan0mon -0 采用deauth攻击模式，后面跟上攻击次数 -a 后跟路由器的mac地址 -c 后跟客户端的mac地址# 直接破解$ aircrack-ng -w Wordlists.txt CAP-01.cap# 转换后用hashcat跑$ cap2hccapx.exe testap.cap test.hccapx$ hashcat64.exe -m 2500 -D 2 test.hccapx pass.txt]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络安全</tag>
        <tag>Kali</tag>
        <tag>Airmon-ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu静态IP和SSH配置]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-ip-xshell%2F</url>
    <content type="text"><![CDATA[静态IP1234567891011121314# 静态IP$ vim /etc/network/interfaces auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.168.1.1# DNS解析$ vim /etc/resolv.conf nameserver 192.168.1.1$ vim /etc/resolvconf/resolv.conf.d/base nameserver 192.168.1.1# 要将/etc/NetworkManager/目录下的system-connections删除，或者移动到其他目录下$ sudo/etc/init.d/networking restart # 重启网卡 安装SSH12345678# 安装SSH$ sudo apt-get install openssh-server # 安装$ ps -e |grep ssh # 查看$ /etc/init.d/ssh start # 启动# 如果无法启动$ vim /etc/ssh/sshd_config # 将 PermitRootLogin改为yes：$ sudo /etc/init.d/ssh restart]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Ftp和Smaba]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-ubuntu-ftp-smaba%2F</url>
    <content type="text"><![CDATA[安装FTP123456789101112131415161718192021# 安装FTP$ apt-get install vsftpd# 添加用户和权限# 新建"/home/uftp"目录作为用户主目录# 新建用户uftp并设置密码$ sudo useradd -d /home/uftp -s /bin/bash uftp$ passwd uftp XXX$ vim /etc/vsftpd.conf # 配置文件 userlist_deny=NO userlist_enable=YES userlist_file=/etc/allowed_users seccomp_sandbox=NO chroot_list_enable=YES chroot_list_file=/etc/chroot_list# 添加用户uftp到allowed_users,chroot_list$ vim /etc/allowed_users$ vim /etc/chroot_list# 启动/关闭/重启服务$ sudo /etc/init.d/vsftpd start$ sudo /etc/init.d/vsftpd stop$ sudo /etc/init.d/vsftpd restart 安装Samba123456789101112131415161718192021222324252627# 安装Samba$ sudo apt-get install samba# smbclient: $ sudo apt-get install smbclient# 修改配置文件$ vim /etc/samba/smb.conf# 在文件末尾加上如下[share]（相当于在home目录项增加了一个新用户） [share] comment = Share Folder require password browseable = yes path = /home/share create mask = 0777 directory mask = 0777 valid users = share force user = nobody force group = nogroup public = yes writable = yes available = yes# 保存退出后重启samba：$ sudo /etc/init.d/samba restart# 切换到 /home/目录下创建一个用户目录：$ sudo mkdir share# 设置目录的权限：（777代表最高权限，可读可写可执行）$ chmod 777 share# 添加用户到samba$ smbpasswd -a starbucks]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>FTP</tag>
        <tag>Ubuntu</tag>
        <tag>Smaba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql简单安装配置]]></title>
    <url>%2F2018%2F04%2F01%2Fdb-mysql-init%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617# my.ini[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=D:\mysql\mysql-5.6.17-winx64# 设置mysql数据库的数据的存放目录datadir=D:\mysql\mysql-5.6.17-winx64\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB Windows安装服务123$ cd D:\mysql\mysql-5.6.17-winx64\bin$ mysqld install # 安装服务$ mysqld remove # 卸载服务 初始化123$ net start mysql # 启动服务# 先删除 mysql 下的data文件夹$ mysqld --initialize # 初始化 设置密码12345$ net stop MySQL # 关闭服务$ mysqld --skip-grant-tables # 用安全模式打开$ mysql -u root -p # 登录，密码为空，直接回车$ use mysql$ set password for root@localhost = password('123'); 登入12$ mysql -u root -p # 回车输入密码$ mysqladmin -u root -p password 密码 # 设置密码 远程登入1234567$ use mysql# 插入$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; # 刷新$ flush privileges;# 查看是否成功$ select host,user from user; Linux安装123$ wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm$ rpm -ivh mysql-community-release-el7-5.noarch.rpm$ yum install mysql-community-server 启动/关闭服务1$ service mysqld restart/stop 设置密码123$ mysql -u root # 首次无密$ use mysql$ set password for root@localhost = password('123'); 远程登录1234# 把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户$ grant all privileges on *.* to root@'%'identified by 'password'# 如果是新用户而不是root，则要先新建用户$ create user 'username'@'%' identified by 'password']]></content>
      <categories>
        <category>DBπ</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2018%2F04%2F01%2Fdb-mongodb-basis%2F</url>
    <content type="text"><![CDATA[MongoDB安装123456$ cd d:/soft/mongodb/bin# 设置log和data路径，需要创建data文件夹$ mongod.exe --logpath E:\DB\MONGO_DB\mongodb.log --logappend --dbpath E:\DB\MONGO_DB\data --directoryperdb --serviceName MongoDB -install $ net start MongoDB # 启动服务$ net stop MongoDB # 停止服务 MongoDB基础使用123456$ db.getCollection('email_zero').find(&#123;&#125;) # 查询表$ db.email_zero.stats() # 表信息$ db.email_zero.ensureIndex(&#123;"email":1&#125;) # 建立索引$ db.email_zero.find(&#123;"email":"123@163.com"&#125;).pretty() # 查询例子# 导出数据$ mongoexport -d admin -c mydb --csv -f tid,uid,username,isupdate,phone -o mydb.dat 去重脚本12345678var rs = db.email_zero.aggregate([&#123;$group:&#123;_id:"email",count:&#123;$sum:1&#125;&#125;&#125;,&#123;$match:&#123;count:&#123;$gt:1&#125;&#125;&#125;])for(var i in rs.result)&#123; var r = rs.result[1].count; var k = rs.result[1]._id; for(var ii=0;ii&lt;r-1;ii++)&#123; db.biu.remove(&#123;"email":k&#125;,true) &#125; &#125;]]></content>
      <categories>
        <category>DBπ</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F04%2F01%2Fhexo-learning%2F</url>
    <content type="text"><![CDATA[12345678# 安装Hexo$ npm install -g hexo-cli​# 文件夹初始化$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install# next主题$ git clone https://github.com/iissnan/hexo-theme-next themes/next 常用插件12345678# 安装less，主题默认使用less作为css预处理工具。$ npm install hexo-renderer-less --save# 安装feed，用于生成rss。$ npm install hexo-generator-feed --save# 安装json-content，用于生成静态站点数据，用作站内搜索的数据源。$ npm install hexo-generator-json-content --save# 远程推送$ npm install hexo-deployer-git --save hexo命令1234567891011121314$ hexo new post title #生成新页$ hexo -d #提交给git$ hexo -w #监视文章文件变动$ hexo -s #启动服务$ hexo -g #生成页面$ hexo list &lt;type&gt;$ hexo --safe #安全模式$ hexo --debug #调试模式$ hexl --slient #简洁模式# 重新安装hexo-util $ npm install -- save-dev hexo-util# 如果出现# Block-scoped declarations (let, const, function, class) not yet supported outside strict mode$ 'use strict' 其他插件12345678910# hexo-addlink：在文章最末添加永久链接及版权声明，建议安装# hexo-generator-search: 本地搜索# hexo-index-anything: 更改首页为任意的页面# hexo-encrypt：加密你的博客# hexo-ruby-character 文字拼音# hexo Tag Cloud 标签云# hexo-uuid# sitemap 站点地图$ npm install hexo-generator-searchdb --save$ npm uninstall ​ 踩坑12345678#1.node版本过高，导致报错brew uninstall nodebrew install node@12brew link --overwrite --force node@12#2.大小写敏感git config core.ignorecase false#3.tag-404先删除/public下的tag文件夹，提交到远程仓库。再重新hexo g d。]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F04%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[123# 设置用户名和邮箱$ git config --global user.name "name"$ git config --global user.email "***@**.com" 1234# 生成公钥$ ssh-keygen -t rsa -C "email"$ ssh -T git@git.oschina.net $ ssh -T git@github.com 查看信息1$ git config --list 文本编辑器1$ git config --global core.editor emacs 代码比较1$ git config --global merge.tool vimdiff 创建版本库123456789101112131415161718192021222324252627282930# 选择一个合适的地方，创建一个空目录：$ mkdir xxoo$ cd xxoo$ pwd# 把这个目录变成Git可以管理的仓库：$ git init# 1.把文件添加到仓库$ git add readme.txt# 2.把文件提交到仓库$ git commit -m "wrote a readme file"# 检查文件状态$ git status# 忽略某些文件$ cat .gitignore *.[oa] *~# 查看尚未暂存的文件更新了哪些部分$ git diff# 要看已经暂存起来的文件和上次提交时的快照之间的差异$ git diff - staged# 提交更新$ git commit -m "xxx"# 跳过使用暂存区域$ git commit -a -m "xxx"# 移除文件 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强删除选项 -f$ git rm xxx# 仅是从跟踪清单中删除$ git rm --cached XXX# 日志$ git log --pretty=oneline 版本123456789101112# 版本回退 git 用head表示当前版本 head^上一个版本$ git reset --hard HEAD^# 回到任意版本$ git reset --hard commitId# 用来记录你的每一次命令：$ git reflog# 撤销修改(文件在工作区的修改全部撤销)# 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；# 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。$ git checkout -- file# 暂存区的修改撤销掉（unstage），重新放回工作区$ git reset HEAD file 远程仓库github1234567$ git remote add origin git@oschina.net:***/***.git# 本地库push到github （第一次用-u，后面就不用）$ git push -u origin master # 克隆别人项目(mycode 自定义目录名称)$ git clone git://url mycode# 查看远程仓库(详情)$ git remote -v 分支管理12345678910111213141516171819202122232425262728# 参数表示创建并切换$ git checkout -b dev# 查看当前分支 *$ git branch# 切换分支$ git checkout master# 合并分支$ git merge dev# 删除分支$ git branch -d dev# 强行删除未合并分支$ git branch -D name# 分支合并图$ git log --graph --pretty=oneline --abbrev-commit# 禁用fast forward$ git merge --no--ff -m "xxoo" dev# 1.可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：# 2.创建bug分支，临时分支# 3.切回分支 查看工作区# 4.回复工作区$ git stash$ git checkout -b issue-101$ git stash list$ git stash apply $ git stash drop# 或者$ git stash pop# 多次stash，再恢复指定stash$ git stash apply stash&#123;*&#125; 推送分支到远程(多人管理)12345$ git push origin master# git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送$ git pull# git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：$ git branch --set-upstream dev origin/dev 标签123456789101112131415# 打标签+id$ git tag v1.0 123456# 查看标签详情$ git show v1.0# 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：$ git tag -a v1.0 -m 'xxoo' 123456# 删除$ git tag -d v1.0# 推到远程,一次性推送全部尚未推送到远程的本地标签：$ git push origin v1.0$ git push origin --tags# 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v1.0# 然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin :refs/tags/v1.0 推送失败12345$ cd to .git/config$ vim vonfig # url = $ git pull --rebase origin master# 执行上面代码后可以看到本地代码库中多了README.md文件]]></content>
      <categories>
        <category>运维π</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试清单]]></title>
    <url>%2F2018%2F04%2F01%2Ftest-black-box-testing%2F</url>
    <content type="text"><![CDATA[收集信息 手动访问站点 使用爬虫来抓取（手工）无法访问或隐藏的内容 检查泄露信息的文件，如robots.txt, sitemap.xml, .DS_Store 检查主要的搜索引擎索引的此站点的公开内容 检查不同的浏览器UA获取的内容的差异（如使用爬虫的UA访问手机站点） 检查WEB应用程序的指纹（Fingerprinting） 确认使用的技术 确认用户角色 确认应用程序的入口地址 确认客户端代码 确认不同的版本的差异（如web, mobile web, mobile app, web services） 确认位于同一主机或业务相关的应用程序 确认所有的主机名和端口 确认第三方的托管内容 配置管理 检查常用的应用程序和管理URL 检查旧文件、备份文件和未引用文件是否存在 检查支持的HTTP方法和XST漏洞 检查对文件后缀的处理 检查安全HTTP头（如CSP, X-Frame-Options, HSTS） 测试安全策略（如Flash, Silverlight, robots） 在线上环境测试非生产数据或做相反的操作 检查客户端代码中的敏感信息（如API keys,凭据等） 安全传输 检查SSL版本、算法和密钥长度 检查数字证书有效性 检查凭据是否只通过HTTPS传输数据 检查登陆表单是否只通过HTTPS传输数据 检查会话令牌是否只通过HTTPS传输 检查是否使用了HSTS 认证 测试枚举用户 测试认证绕过 测试暴力破解保护 测试密码规则的质量 测试记住密码功能 测试密码表单的自动完成的功能 测试密码重置和找回 测试密码修改流程 测试验证码 测试多因子认证 测试注销功能 测试HTTP的缓存管理（如Pragma, Expires, Max-age） 测试默认登陆账号 测试用户认证历史 测试账号锁定和密码修改成功的通知渠道 测试跨应用程序共享模式/SSO的一致性 会话管理 确定应用程序管理会话的方式（如将cookie tokens、url中的token） 检查会话cookie的标示(httpOnly和secure) 检查会话cookie的返回（path和domain） 检查会话cookie的有效期（expires和 max-age） 检查会话cookie的过期失效 检查会话cookie的相对超时失效 检查会话cookie退出后失效 测试用户是否可以同时拥有多个会话 测试会话cookie的随机性 确认会话令牌在登陆、角色变化和退出时的更新 测试跨应用共享session会话的一致性 测试会话过载（未限制会话应用范围） 测试是否存在CSRF和点击劫持漏洞 授权 测试路径遍历 测试绕过授权 测试垂直访问控制问题 测试水平访问控制问题 测试授权检查缺失 数据验证 测试反射型XSS 测试存储型XSS 测试DOM型XSS 测试CSF（flash XSS） 测试HTML注入 测试SQL注入 测试LDAP注入 测试ORM注入 测试XML注入 测试XXE注入 测试SSI注入 测试XPath注入 测试XQuery注入 测试IMAP/SMTP注入 测试Code注入 测试EL注入 测试Command注入 测试Overflow （堆, 栈和整形溢出） 测试Format String（错误的字符串格式化） 测试incubated vulnerabilities（缺陷孵化） 测试HTTP Splitting/Smuggling（协议层） 测试HTTP Verb Tampering（权限干涉） 测试Open Redirection 测试本地文件包含 测试远程文件包含 比较客户端与服务端的验证规则 测试NoSQL注入 测试HTTP参数污染 测试自动绑定 测试Mass Assignment（ror经典漏洞） 测试NULL/Invalid Session Cookie 拒绝服务 测试反自动化/机器请求 测试账号锁定 测试HTTP 协议DoS 测试SQL通配符DoS/sleep Dos 业务逻辑 测试功能滥用 测试缺乏不可否认性（非对称加密作用） 测试信任关系 测试数据完整性 测试指责分离 密码学 检查应加密数据是否加密 根据上下文检查是否使用了错误的算法 检查使用弱算法 检查是否合理使用盐 检查随机函数（的随机性） 风险功能—文件上传 检查可接受的文件类型是否在白名单内 检查文件尺寸限制、上传频率和总文件数的阈值与限制情况 检查文件内容是否与定义的文件类型相符 检查所有上传的文件都经过杀毒软件扫描 检查不安全的文件名是否经过处理 检查不能在web根目录下直接访问上传文件 检查上传的文件是否存储在相同的主机名和端口 检查文件和其他媒体继承了身份验证和授权功能 风险功能—支付信息 测试WEB服务器或应用程序是否存在已知漏洞和配置问题 测试默认或易被猜到的密码 测试生产环境的非生产数据或做相反的* 测试 测试注入漏洞 测试缓冲区溢出 测试不安全的加密存储 测试传输层保护不足 测试不适当的错误处理 测试CVSS v2 评分&gt; 4.0的全部漏洞 测试身份验证和授权的问题 测试CSRF HTML 5 测试WEB消息传递 测试WEB本地存储SQL注入 检查CORS的实现 检查离线的WEB应用程序]]></content>
      <categories>
        <category>测试π</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMap]]></title>
    <url>%2F2018%2F04%2F01%2Flinux-kali-sqlmap%2F</url>
    <content type="text"><![CDATA[12345678910111213# 判读是否有注入点 ​$ python sqlmap.py -u 'RUL'# 获取数据库$ python sqlmap.py -u 'RUL' --dbs# 当前使用数据库$ python sqlmap.py -u 'RUL' --current-db# 获取指定库的所有表$ python sqlmap.py -u 'RUL' --table -D "数据库名"#获取表中的字段$ python sqlmap.py -u 'RUL' --columns -T "表名" -D "数据库名"#读取指定字段内容$ python sqlmap.py -u 'RUL' --dump -C "字段，字段，字段" -T "表名" -D "数据库名"#(dump为转存数据） 常用参数12345678910111213141516171819202122232425262728293031323334353637# 测试注入点权限$ python sqlmap.py -u 'RUL' --privileges #所有用户权限$ python sqlmap.py -u 'RUL' --privileges -U sa #sa用户权限# 执行shell命令$ python sqlmap.py -u 'RUL' --os-cmd="net user" #执行net user命令$ python sqlmap.py -u 'RUL' --os-shell #系统交互的shell#执行sql命令$ python sqlmap.py -u 'RUL' --sql-shell #sql交互shell$ python sqlmap.py -u 'RUL' --sql-query="sql语句"# post提交方式$ python sqlmap.py -u 'RUL' --data "post参数"# 显示详细等级 # 0：只显示Python的回溯，错误和关键消息。 # 1：显示信息和警告消息。 # 2：显示调试消息。 # 3：有效载荷注入。 # 4：显示HTTP请求。 # 5：显示HTTP响应头。 # 6：显示HTTP响应页面的内容 $ python sqlmap.py -u 'RUL' -v 1 #注入http请求$ python sqlmap.py -r head.txt --dbs [head.txt POST /login.php HTTP/1.1 Host:www.secbug.org User-Agent:Mozilla/5.0 username=admin&amp;password=admin888]# 直接连接数据库$ python sqlmap.py -d "mysql://admin:admin@127.0.0.1:3306/test" --dbs# 注入等级$ python sqlmap.py -u 'RUL' --leavl 3# 语句插入到指定位置$ python sqlmap.py -u 'http://www.xxser.com/id/2*.html' --dbs# 使用插件$ python sqlmap.py -u 'RUL' -tamper "插件名"# 获取帮助$ python sqlmap.py -h 🌰🌰🌰1234567891011121314151617181920212223242526272829# 🌰：$ SELCECT *$ FORM products$ WHERE category = 'bike' AND '1'='2'$ UNION SELECT *$ FROM new_products;# 🌰：$ SELECT *$ FROM products$ WHERE idproduct = 1+1 (?id=%2B1)(+的url编码%2B)# 数据库注释# SQLserver Oracle Postgresql --(双联字符) /* */# Mysql -- # /* */# 数据库服务器版本# SQLserver $ select @@version# Mysql$ select version()$ select @@version# Oracle$ select banner from v$version$ select banner from v$version where rownum=1# Postgresql$ select version()]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Kali</tag>
        <tag>Sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali源更换]]></title>
    <url>%2F2018%2F04%2F01%2Fcs-kali-sources-list-and-ssr%2F</url>
    <content type="text"><![CDATA[123456789$ wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add $ vim /etc/apt/sources.list​#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib​$ apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade ​$ apt-get clean ​# apt-get dist-upgrade 更新系统以及所有依赖包$ apt-get installopen-vm-tools-desktop fuse #安装开源vm tools Kali-ss123456789$ apt-get install qt5-qmake qtbase5-dev libbotan1.10-dev pkg-config debhelper libqrencode-dev libzbar-dev libappindicator-dev cmake # 安装编译环境$ git clone https://github.com/shadowsocks/libQtShadowsocks.git #克隆项目$ dpkg-buildpackage -uc -us -b$ dpkg -i ../libqtshadowsocks_1.10.0-1_amd64.deb ../libqtshadowsocks-dev_1.10.0-1_amd64.deb# 若出错，则更改版本信息$ git clone https://github.com/shadowsocks/shadowsocks-qt5.git$ dpkg-buildpackage -uc -us -b$ dpkg -i ../shadowsocks-qt5_2.8.0-1_amd64.deb Win-ss1$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh Tor-network-bridgeobfs2网桥 、obfs3网桥、obfs4网桥（推荐） 、scramblesuit网桥]]></content>
      <categories>
        <category>安全π</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络安全</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理与方法论]]></title>
    <url>%2F2018%2F04%2F01%2Ftime-management%2F</url>
    <content type="text"><![CDATA[时间管理有很多种方法，而GTD（全称：Getting Things Done）就是其中一套行之有效的方法，也是现在最受欢迎的方法。Getting Things Done 翻译成中文就是“把事情做完”，GTD的核心理念概括就是 “通过记录的方式把头脑中的各种事情移出来，然后整理安排自己去执行”。带着一些自己的理解，下面谈一谈我对GTD的理解以及方法论，GTD的核心步骤为五步：收集、处理、管理、执行、回顾。 收集 —— 收集记录人的大脑能储存很多东西，但有限，不要相信某事情发生后过了一段时间你还能记得，释放大脑的储存负载，让大脑着重于去思考，平时有什么信息、任务和灵感要在忘记之前用工具记录下来，使用的工具要尽可能的方便，易用，便捷。 处理 —— 处理分类只有及时处理信息，对信息及时做出决定和归纳成类，你才能避免信息的堆积和碎片化，处理信息时采用二分钟法则和四象限法则，二分钟方法就是如果一件事情两分钟内能解决的事情，无论是何种事情，马上着手解决掉，如果不能再进行分类。分类则采用四象限法则，四象限法则是把工作按照重要和紧急两个不同的程度划分成四个“象限”：既紧急又重要、重要但不紧急、紧急但不重要、既不紧急也不重要。 计划 —— 计划安排除了既有的日程安排外，可以设定每日，每周，每月，每年你需要完成的重大事件，把他们排进日程表。每天要做的事件采用三只青蛙理论，前天晚上睡觉前设定第二天最重要的三件事，起床后就可以开始着手这三件事了（同理可用于每月的“三只青蛙”, 每季度的“三只青蛙”，每年的“三只青蛙”）。每周要做的事采用习惯21天效应，一件事只要坚持21天就能习惯成自然，成为一种习惯。每月要做的事采用日历行程表的方法，将每月要做的事排进日程表。每年要做的事采用原望清单法，让自己每年都有收获和进步. 执行 —— 坚决执行执行是Getting Things Done最关键的一步，也是成功与否的关键，要言行一致，制定了计划就一定得做到，这能很好地提升你的自我认同感。执行时你应当在不分心的情境下，一次只执行一件事，既不要多线工作，也不要让你的工作突然中断。采用番茄工作法，将番茄时间设为25分钟，专注工作，中途不做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息5分钟继续番茄时钟，每4个番茄时段可多休息一会儿。番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。 回顾 —— 回顾检查目前我采用的是一周回顾一次，采用PDCA循环法对长期目标、中期目标和短期目标进行回顾，对工作和其它事情进行回顾，看看哪里做的不好，需要改进，重新做出调整计划。这样能使得计划更有效地进行，更加合乎工作程序的逻辑。]]></content>
      <categories>
        <category>时间π</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Search]]></title>
    <url>%2F2018%2F03%2F31%2Fg00gle-search%2F</url>
    <content type="text"><![CDATA[搜索知乎上的相关话题：1intext:"星巴克" site:zhihu.com/question/ 搜索百度网盘上的资料1intitle:"星巴克" site:pan.baidu.com 日常生活类1weather/time/sunrise/sundown+Seattle 查询作者的全部作品1books by Starbucks 查询几个信息（ + 、or 号的运用）12“星巴克 + Starbucks”“星巴克 or Starbucks” 找图片1234可以使用inurl语法迅速找到想要的图片搜索：“星巴克” inurl:photo可以用intitle语法找到这类网页。搜索：“intitle:“星巴克” picture” 找软件123451）直接以软件名称以及版本号为关键字查询。2）可以增加“下载”或者“download”为关键字。3）用“” 精确搜索，如：搜索：“winzip 8.0 下载”4）可以用inurl语法直接搜索这些下载目录搜索：PS inurl:download （搜索PS 软件下载） “” 双引号表示完全匹配，搜索：“星巴克” A -B搜索包含A但不包含B的结果（请注意A后面的空格不能省略） 模糊搜索：很多时候想搜一个东西但是不确定具体名字，可以用星号代替忘了的字，像搜 [星*克]； site 搜索结果局限于某个具体网站1site:starbucks.com.cn 注意：site后的冒号为英文字符，而且，冒号后不能有空格，否则，“site:”将被作为一个搜索的关键字。此外，网站域名不能有“http”以及“www”前缀，也不能有任何“/”的目录后缀； link 返回所有链接到某个URL地址的网页。12示例：搜索所有含指向星巴克“www.starbucks.com.cn”链接的网页。搜索：“link:www.starbucks.com.cn” inurl 用于搜索查询词出现在url 中的页面12345搜索：inurl:搜索引擎优化返回的结果都是网址url中包含“搜索引擎优化”的页面。由于关键词出现在url中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手示例：搜索关于星巴克公司的PDF文档。搜索：inurl:pdf 星巴克 或者inurl:pdf 星巴克 简介 intitle 返回的是页面title 中包含关键词的页面1intitle:“星巴克” Allintitle 搜索返回的是页面标题中包含多组关键词的文件12搜索：allintitle:Starbucks 星巴克就相当于：intitle:Starbucks intitle:星巴克 filetype 用于搜索特定文件格式。12搜索：filetype:pdf Starbucks返回的就是包含Starbucks 这个关键词的所有pdf文件。 一些好玩的1zerg rush # 页面上方降下很多圆圈]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码风格和PEP8]]></title>
    <url>%2F2018%2F03%2F31%2Fpython-code-style-pep8%2F</url>
    <content type="text"><![CDATA[变量 常量 : 大写加下划线1USER_CONSTANT 对于不会发生改变的全局变量，使用大写加下划线。 私有变量 : 小写和一个前导下划线1_private_value Python 中不存在私有变量一说，若是遇到需要保护的变量，使用小写和一个前导下划线。但这只是程序员之间的一个约定，用于警告说明这是一个私有变量，外部类不要去访问它。但实际上，外部类还是可以访问到这个变量。 内置变量 : 小写，两个前导下划线和两个后置下划线1__class__ 两个前导下划线会导致变量在解释期间被更名。这是为了避免内置变量和其他变量产生冲突。用户定义的变量要严格避免这种风格。以免导致混乱。 函数和方法总体而言应该使用，小写和下划线。但有些比较老的库使用的是混合大小写，即首单词小写，之后每个单词第一个字母大写，其余小写。但现在，小写和下划线已成为规范。 私有方法 : 小写和一个前导下划线12def _secrete(self): print("Starbucks") 这里和私有变量一样，并不是真正的私有访问权限。同时也应该注意一般函数不要使用两个前导下划线(当遇到两个前导下划线时，Python 的名称改编特性将发挥作用)。 特殊方法 ：小写和两个前导下划线，两个后置下划线12def __add__(self, other): return int.__add__(other) 这种风格只应用于特殊函数，比如操作符重载等。 函数参数 : 小写和下划线，缺省值等号两边无空格12def connect(self, user=None): self._user = user 类类总是使用驼峰格式命名，即所有单词首字母大写其余字母小写。类名应该简明，精确，并足以从中理解类所完成的工作。常见的一个方法是使用表示其类型或者特性的后缀，例如:SQLEngine、MimeTypes。对于基类而言，可以使用一个 Base 或者 Abstract 前缀，例如:BaseCookie、AbstractGroup123456class UserProfile(object): def __init__(self, profile): return self._profile = profile def profile(self): return self._profile 模块和包除特殊模块 __init__ 之外，模块名称都使用不带下划线的小写字母。若是它们实现一个协议，那么通常使用lib为后缀，例如:123import smtplibimport osimport sys 关于参数 不要用断言来实现静态类型检测断言可以用于检查参数，但不应仅仅是进行静态类型检测。Python 是动态类型语言，静态类型检测违背了其设计思想。断言应该用于避免函数不被毫无意义的调用。 不要滥用 *args 和 **kwargs*args 和 **kwargs 参数可能会破坏函数的健壮性。它们使签名变得模糊，而且代码常常开始在不应该的地方构建小的参数解析器。 其他 使用 has 或 is 前缀命名布尔元素 12is_connect = Truehas_member = False 用复数形式命名序列 1members = ['user_1', 'user_2'] 用显式名称命名字典 1person_address = &#123;'user_1':'10 road WD', 'user_2' : '20 street huafu'&#125; 避免通用名称诸如 list, dict, sequence 或者 element 这样的名称应该避免。 避免现有名称诸如 os, sys 这种系统已经存在的名称应该避免。 一些数字 一行列数 : PEP 8 规定为 79 列，这有些苛刻了。根据自己的情况，比如不要超过满屏时编辑器的显示列数。这样就可以在不动水平游标的情况下，方便的查看代码。 一个函数 : 不要超过 30 行代码, 即可显示在一个屏幕类，可以不使用垂直游标即可看到整个函数。 一个类 : 不要超过 200 行代码，不要有超过 10 个方法。 一个模块 不要超过 500 行。]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda]]></title>
    <url>%2F2018%2F03%2F31%2Fpython-anaconda%2F</url>
    <content type="text"><![CDATA[添加Anaconda的TUNA镜像1$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 设置搜索时显示通道地址1$ conda config --set show_channel_urls yes 创建一个名为python36的环境，指定Python版本是3.61$ conda create --name python36 python=3.6 # conda会为我们自动寻找3.6.x中的最新版本 安装好后，使用activate激活某个环境12$ activate python36 # for Windows$ source activate python36 # for Linux &amp; Mac 查看当前版本1$ python --version 如果想返回默认的python 2.7环境，运行12$ deactivate python27 # for Windows$ source deactivate python27 # for Linux &amp; Mac 删除一个已有的环境1$ conda remove --name python34 --all 查看当前环境下已安装的包1$ conda list 查看某个指定环境的已安装包1$ conda list -n python36 查找package信息1$ conda search *包名 安装package1$ conda install -n python36 *包名 # 如果不用-n指定环境名称，则被安装在当前活跃环境 更新package1$ conda update -n python36 *包名 删除package1$ conda remove -n python36 *包名 更新conda，保持conda最新1$ conda update conda 更新anaconda1$ conda update anaconda 更新python1$ conda update python]]></content>
      <categories>
        <category>技术π</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星巴克入门·咖啡篇]]></title>
    <url>%2F2018%2F01%2F30%2Fstarbucks-quickstart-guide-coffee%2F</url>
    <content type="text"><![CDATA[在星巴克常见的几款咖啡有美式咖啡、拿铁咖啡、卡布奇诺、摩卡咖啡、焦糖玛奇朵、馥芮白，通过定制可以做出适合自己口味的咖啡。以下就介绍这几款咖啡的制作和特点。 Espresso 意式浓缩咖啡以7-8公克深度烘焙的综合咖啡豆，研磨成极细的咖啡粉，经过9个大气压与摄氏92度左右的高温热水，在15秒的短时间内急速萃取30毫升的浓烈咖啡液体称之为「Espresso」，也是其他咖啡饮料的基底 Caffè Americano 美式咖啡成分：浓缩咖啡 + 热水,一杯美式咖啡由两份意式浓缩咖啡加30到470ml热水混合而成特点：较好的保留咖啡原有的醇香，提神效果较好Bigger：夏天可以点一杯冰美式，巨苦巨提神，味道不是一般人可接受 Caffè Latte 拿铁咖啡成分：浓缩咖啡 + 牛奶 + 奶泡(较少)特点：无糖，奶泡轻柔。传统的经典饮料，美妙之处也在于它的简单Bigger：Latte Art 「拉花拿铁」，点咖啡时可以要求使用马克杯装，这样咖啡师就会为你拉出不同样式 Cappuccino 卡布奇诺成分：浓缩咖啡 + 牛奶 + 奶泡(较多)特点：与拿铁的区别就在于有一半奶泡，因此口感比拿铁浓郁，奶泡越细腻越好，但是要及时喝完，时间久了奶泡没了比较难喝Bigger：在奶泡上洒上些许肉桂粉、可可粉或是橙橘柠檬类的果皮丝用以装饰或增加风味 Café Mocha 摩卡咖啡成分：浓缩咖啡 + 牛奶 + 巧克力酱 + 鲜奶油(whipped cream)Bigger：White Chocolate Mocha 白巧克力摩卡咖啡，这款饮料特别温暖，适合女生，适合冬季 Caramel Macchiato 焦糖玛奇朵成分：香草糖浆 + 牛奶 + 奶泡 + 浓缩咖啡 + 焦糖糖浆Bigger：推荐搭配 Chocolate Old Fashion（巧克力甜甜圈） Flat White 馥芮白成分：精萃浓缩咖啡（ristretto）+ 牛奶 + 奶泡特点：特有的白点]]></content>
      <categories>
        <category>Starbucksπ</category>
      </categories>
      <tags>
        <tag>星巴克</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星巴克入门·基础篇]]></title>
    <url>%2F2018%2F01%2F30%2Fstarbucks-quickstart-guide%2F</url>
    <content type="text"><![CDATA[星巴克股份有限公司（英语：Starbucks Corporation，简称：星巴克，英语：Starbucks）是美国一家跨国连锁咖啡店，也是全球最大的连锁咖啡店，发源地与总部位于美国华盛顿州西雅图。除咖啡之外，亦有茶饮等饮料，以及三明治、糕点等点心类食品。其成立于1971年，最初仅专卖咖啡豆，在转型为现行的经营型态后开始快速展店，并成为美式生活的象征之一，部分店铺甚至与超级市场、书店等异业结盟，以复合式商店经营。目前，星巴克已经在中国130个城市开设了2,800家门店，拥有近40,000名身穿绿围裙的星巴克伙伴。 Q&amp;A星巴克有哪些店面类型？ 普通店：只出售以9个大气压冲泡出来的意式浓缩咖啡，及其衍生咖啡及饮品 手冲店：提供高温高压的冲泡方式，也可按客人要求，以手冲壶来冲咖啡 臻选店：提供一般店所没有的臻选咖啡豆供客人选择，臻选店特有「★|R」标志 Q&amp;A星巴克有哪些颜色的围裙？ 「绿色」这是最普遍的围裙颜色，一般兼职员工及正职员工穿的都是绿色围裙，这代表的是他们受过公司的统一训练，能够独自为客人服务 「黑色」穿著黑色围裙的店员被称为「咖啡大师 Coffee Master」，只有通过每年一度「精品咖啡大使」选拔的人才能够穿上，这些店员都具备丰富的咖啡知识，并且能准确调配出客户所点选的咖啡。在臻选店中所有员工都是穿黑色围裙，但是不一定都是Coffee Master 「咖啡色」最稀有的咖啡色围裙则是星巴克在世界各地比赛，选出代表全球的「咖啡大使 Coffee Ambassdor」，他们可说是来自全球各地的星巴克咖啡团队代表 「紫色」2016 年葡萄牙店的助理经理 Fabio da Silva Neno 拿下了星巴克集团举办的 EMEA Barista Championship 的总冠军，因此被加冕「紫色围裙」的殊荣 Q&amp;A星巴克有哪几种杯型？总共有5种，小杯「Short,8oz」，中杯「Tall,12oz」，大杯「Grande 16oz」，超大杯「Venti,20oz」，特大杯「Trenta,30oz」。oz是重量单位盎司，1盎司=28.35g。Short size仅供kid’s drinks和espresso使用，并且没有展示。Trenta size只用于iced coffee &amp; iced tea，这里的”iced coffee”不包括espresso drinks，目前国内似乎没有这个size的杯子。 Q&amp;A星巴克杯子上的英文是什么意思？「Decaf :: 咖啡因」 X : 无咖啡因 1/2 : 一半 「Shots :: 几份espresso」（除了美式以外，其他意式饮料espresso的份量均为：tall(一份浓缩）grand(两份浓缩）venti（两份浓缩）） 1 : 1 Shot 2 : 2 Shots… 「Syrup :: 糖浆」 A : Almond 杏仁 C : Caramel 焦糖 CH : Chai 印度茶 S/CL : Signature/Classic 经典糖浆 CN : Cinnamon 肉桂 H : Hazelnut 榛果 I : Irish Cream 爱尔兰奶油 MO : Mocha Syrup 摩卡糖浆 P : Peppermint 薄荷 R : Raspberry 覆盆子糖浆 SFH : Sugar Free Hazelnut 无糖榛子 SFV : Sugar Free Vanilla 无糖香草 V : Vanilla 香草 WM : White Chocolate Mocha Syrup 白巧克力摩卡糖浆 「Milk :: 牛奶」 B : Breve(half-and-half) 一半奶油一半牛奶 E : Eggnog(seasonal) 蛋酒 % : 50% whole, 50% non-fat 全脂50％，无脂50％ N : Nonfat 脱脂 L : Lowfat 低脂 S : Soy 豆奶 O : Organic Milk 有机牛奶 「Custom :: 定制」 CR : Caramel Sauce 焦糖酱 D : Dry 干 DB|2xB : Double Blended 双混合 F : Foamy 泡沫的 H : Hot 热的 HANDOFF : Deliver to customer’s table 送到客户桌边 K : Kid’s Beverage(tiny size, cooler temperature) 小孩类型的… NW : No Water 不要水 NF : No Foamy 不要奶泡 SL : Sweet’n Low 糖精 SP : Splenda 蔗糖素 STRAB : Strawberry Fruit Sauce 草莓水果酱 SR : Sugar in the raw 原糖 VBEAN : Vanilla Bean Powder 香草豆粉 W : Wet 湿 WC : Whipped Cream 奶油 L : Little 少加 X : Extra 多加 = : Equal 等于 / : Delete 去除 「Drink :: 类型」 A : Caffè Americano 美式咖啡 C : Cappuccino 卡布奇诺 CM : Caramel Macchiato 焦糖玛奇朵 E : Espresso 意式浓缩 L : Caffè Latte 拿铁咖啡 M : Café Mocha 摩卡咖啡 FW : Flat White 馥芮白 F : Frappuccino 星冰乐]]></content>
      <categories>
        <category>Starbucksπ</category>
      </categories>
      <tags>
        <tag>星巴克</tag>
      </tags>
  </entry>
</search>
